From dd8cd5a2fbf7bd18e945bc8a1ff9ce1e3ab30bf0 Mon Sep 17 00:00:00 2001
From: Murat Sezgin <msezgin@codeaurora.org>
Date: Wed, 11 Mar 2020 16:47:15 -0700
Subject: [PATCH] net: bridge : delete fdb entry before callbacks

Ageing timer expires and deletes corresponding fdb entry. Registered
callbacks for br_fdb_update_notifier chains are called one by one.
Since callback invocation is before the deletion of fdb entry,
it may lead to race condition. Fix is to reorder it.

Change-Id: Idefce6d879bfa6104cadc495aa61d164db214c97
Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
---
 net/bridge/br_fdb.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -356,6 +356,7 @@ void br_fdb_cleanup(struct work_struct *
 	unsigned long delay = hold_time(br);
 	unsigned long work_delay = delay;
 	unsigned long now = jiffies;
+	u8 mac_addr[6];
 
 	/* this part is tricky, in order to avoid blocking learning and
 	 * consequently forwarding, we rely on rcu to delete objects with
@@ -383,9 +384,10 @@ void br_fdb_cleanup(struct work_struct *
 		} else {
 			spin_lock_bh(&br->hash_lock);
 			if (!hlist_unhashed(&f->fdb_node)) {
+			    ether_addr_copy(mac_addr, f->key.addr.addr);
+			    fdb_delete(br, f, true);
 			    atomic_notifier_call_chain(&br_fdb_update_notifier_list, 0,
-						       (void *)f->key.addr.addr);
-				fdb_delete(br, f, true);
+						       (void *)mac_addr);
 			}
 			spin_unlock_bh(&br->hash_lock);
 		}
@@ -635,7 +637,8 @@ void br_fdb_update(struct net_bridge *br
 						  &fdb->flags);
 
 				atomic_notifier_call_chain(
-					&br_fdb_update_notifier_list, 0, addr);
+					&br_fdb_update_notifier_list,
+					0, (void *)addr);
 			}
 
 			if (unlikely(test_bit(BR_FDB_ADDED_BY_USER, &flags)))
