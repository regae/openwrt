From 87b8462d7954660acfece5f0ff329f887a3d567e Mon Sep 17 00:00:00 2001
From: Murat Sezgin <msezgin@codeaurora.org>
Date: Fri, 24 Apr 2020 10:58:57 -0700
Subject: [PATCH] net: Enable fast path support for 6RD, DS-Lite

1). Added stats update function
2). Added changes to set the skb->skb_iif to tunnel dev

Change-Id: I7f43746436b4f6483952997fdf91180096d3ed62
Signed-off-by: Shyam Sunder <ssunde@codeaurora.org>
Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
---
 include/net/ip_tunnels.h  |  2 ++
 net/ipv4/ip_tunnel_core.c |  7 +++++++
 net/ipv6/ip6_tunnel.c     | 25 ++++++++++++++++++++++++-
 net/ipv6/sit.c            | 19 +++++++++++++++++++
 4 files changed, 52 insertions(+), 1 deletion(-)

--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@ -567,4 +567,6 @@ static inline void ip_tunnel_info_opts_s
 
 #endif /* CONFIG_INET */
 
+void ipip6_update_offload_stats(struct net_device *dev, void *ptr);
+void ip6_update_offload_stats(struct net_device *dev, void *ptr);
 #endif /* __NET_IP_TUNNELS_H */
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@ -56,6 +56,10 @@ void iptunnel_xmit(struct sock *sk, stru
 	struct net_device *dev = skb->dev;
 	struct iphdr *iph;
 	int err;
+	int skb_iif;
+
+	/* Save input interface index */
+	skb_iif = skb->skb_iif;
 
 	skb_scrub_packet(skb, xnet);
 
@@ -79,6 +83,9 @@ void iptunnel_xmit(struct sock *sk, stru
 	iph->ttl	=	ttl;
 	__ip_select_ident(net, iph, skb_shinfo(skb)->gso_segs ?: 1);
 
+	if (proto == IPPROTO_IPV6)
+		skb->skb_iif = skb_iif;
+
 	err = ip_local_out(net, sk, skb);
 
 	if (dev) {
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -100,6 +100,24 @@ static inline int ip6_tnl_mpls_supported
 #define for_each_ip6_tunnel_rcu(start) \
 	for (t = rcu_dereference(start); t; t = rcu_dereference(t->next))
 
+/*
+ * Update offload stats
+ */
+void ip6_update_offload_stats(struct net_device *dev, void *ptr)
+{
+	struct pcpu_sw_netstats *tstats = per_cpu_ptr(dev->tstats, 0);
+	const struct pcpu_sw_netstats *offload_stats =
+					(struct pcpu_sw_netstats *)ptr;
+
+	u64_stats_update_begin(&tstats->syncp);
+	tstats->tx_packets += offload_stats->tx_packets;
+	tstats->tx_bytes   += offload_stats->tx_bytes;
+	tstats->rx_packets += offload_stats->rx_packets;
+	tstats->rx_bytes   += offload_stats->rx_bytes;
+	u64_stats_update_end(&tstats->syncp);
+}
+EXPORT_SYMBOL(ip6_update_offload_stats);
+
 /**
  * ip6_tnl_lookup - fetch tunnel matching the end-point addresses
  *   @net: network namespace
@@ -1026,6 +1044,9 @@ static int __ip6_tnl_rcv(struct ip6_tnl
 	if (tun_dst)
 		skb_dst_set(skb, (struct dst_entry *)tun_dst);
 
+	/* Reset the skb_iif to Tunnels interface index */
+	skb->skb_iif = tunnel->dev->ifindex;
+
 	gro_cells_receive(&tunnel->gro_cells, skb);
 	return 0;
 
@@ -1107,7 +1128,6 @@ static int ipxip6_rcv(struct sk_buff *sk
 	rcu_read_unlock();
 
 	return ret;
-
 drop:
 	rcu_read_unlock();
 	kfree_skb(skb);
@@ -1416,6 +1436,9 @@ route_lookup:
 	ipv6h->nexthdr = proto;
 	ipv6h->saddr = fl6->saddr;
 	ipv6h->daddr = fl6->daddr;
+
+	/* Reset the skb_iif to Tunnels interface index */
+	skb->skb_iif = dev->ifindex;
 	ip6tunnel_xmit(NULL, skb, dev);
 	return 0;
 tx_err_link_failure:
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@ -90,6 +90,21 @@ static inline struct sit_net *dev_to_sit
 	return net_generic(t->net, sit_net_id);
 }
 
+void ipip6_update_offload_stats(struct net_device *dev, void *ptr)
+{
+	struct pcpu_sw_netstats *tstats = per_cpu_ptr(dev->tstats, 0);
+	const struct pcpu_sw_netstats *offload_stats =
+					(struct pcpu_sw_netstats *)ptr;
+
+	u64_stats_update_begin(&tstats->syncp);
+	tstats->tx_packets += offload_stats->tx_packets;
+	tstats->tx_bytes   += offload_stats->tx_bytes;
+	tstats->rx_packets += offload_stats->rx_packets;
+	tstats->rx_bytes   += offload_stats->rx_bytes;
+	u64_stats_update_end(&tstats->syncp);
+}
+EXPORT_SYMBOL(ipip6_update_offload_stats);
+
 /*
  * Must be invoked with rcu_read_lock
  */
@@ -728,6 +743,8 @@ static int ipip6_rcv(struct sk_buff *skb
 		tstats->rx_bytes += skb->len;
 		u64_stats_update_end(&tstats->syncp);
 
+		/* Reset the skb_iif to Tunnels interface index */
+		skb->skb_iif = tunnel->dev->ifindex;
 		netif_rx(skb);
 
 		return 0;
@@ -1037,6 +1054,8 @@ static netdev_tx_t ipip6_tunnel_xmit(str
 
 	skb_set_inner_ipproto(skb, IPPROTO_IPV6);
 
+	/* Reset the skb_iif to Tunnels interface index */
+	skb->skb_iif = tunnel->dev->ifindex;
 	iptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, protocol, tos, ttl,
 		      df, !net_eq(tunnel->net, dev_net(dev)));
 	return NETDEV_TX_OK;
