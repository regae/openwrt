From d2fd102a2473c64772174cc7f2571f5a3b34074d Mon Sep 17 00:00:00 2001
From: Murat Sezgin <msezgin@codeaurora.org>
Date: Tue, 25 Nov 2014 17:22:24 -0800
Subject: [PATCH] bridge: Add new bridge APIs needed for network HW
 acceleration

Bridge acceleration hardware needs to perform certain operations,
 currently unsupported by the existing bridge code:
 *given a certain bridge device and a MAC@, figure out on
  which underlying slave port this MAC@ is located
 *trigger an FDB entry refresh from outside the bridge code: packets will
  not be seen anymore in the host, once a flow has been accelerated.
  So the hardware accelerator driver needs to keep track of the accelerated
  flows and refresh the MACs accordingly.
 *update bridge interface statistics from outside the bridge code:
  once acceleration is enabled on a connection, packets will not flow
  through the host CPU, so we need the hardware accelerator driver to
  maintain the statistics on the host and update them and add whatever
  flows through the hardware.
 These change adds the corresponding functions, and make it available
 to other through EXPORT_SYMBOLS().

Change-Id: I67afb325796004053897d9916e2df91827b65139
Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
---
 include/linux/if_bridge.h |  5 ++++
 net/bridge/br_fdb.c       | 21 ++++++++++++-
 net/bridge/br_if.c        | 62 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 87 insertions(+), 1 deletion(-)

--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@ -68,6 +68,11 @@ void brioctl_set(int (*hook)(struct net
 			     void __user *uarg));
 int br_ioctl_call(struct net *net, struct net_bridge *br, unsigned int cmd,
 		  struct ifreq *ifr, void __user *uarg);
+extern struct net_device *br_port_dev_get(struct net_device *dev,
+					  unsigned char *addr);
+extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
+extern void br_dev_update_stats(struct net_device *dev,
+				struct rtnl_link_stats64 *nlstats);
 
 #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
 int br_multicast_list_adjacent(struct net_device *dev,
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -638,8 +638,27 @@ void br_fdb_update(struct net_bridge *br
 	}
 }
 
+/* Refresh FDB entries for bridge packets being forwarded by offload engines */
+void br_refresh_fdb_entry(struct net_device *dev, const char *addr)
+{
+	struct net_bridge_port *p = br_port_get_rcu(dev);
+
+	if (!p || p->state == BR_STATE_DISABLED)
+		return;
+
+	if (!is_valid_ether_addr(addr)) {
+		pr_info("bridge: Attempt to refresh with invalid ether address\n");
+		return;
+	}
+
+	rcu_read_lock();
+	br_fdb_update(p->br, p, addr, 0, true);
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL_GPL(br_refresh_fdb_entry);
+
 static int fdb_to_nud(const struct net_bridge *br,
-		      const struct net_bridge_fdb_entry *fdb)
+			const struct net_bridge_fdb_entry *fdb)
 {
 	if (test_bit(BR_FDB_LOCAL, &fdb->flags))
 		return NUD_PERMANENT;
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -785,3 +785,63 @@ bool br_port_flag_is_set(const struct ne
 	return p->flags & flag;
 }
 EXPORT_SYMBOL_GPL(br_port_flag_is_set);
+
+/* br_port_dev_get()
+ *      Using the given addr, identify the port to which it is reachable,
+ *      returing a reference to the net device associated with that port.
+ *
+ * NOTE: Return NULL if given dev is not a bridge or the mac has no
+ * associated port.
+ */
+struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr)
+{
+	struct net_bridge_fdb_entry *fdbe;
+	struct net_bridge *br;
+	struct net_device *pdev;
+
+	/* Is this a bridge? */
+	if (!(dev->priv_flags & IFF_EBRIDGE))
+		return NULL;
+
+	/* Lookup the fdb entry */
+	br = netdev_priv(dev);
+	rcu_read_lock();
+	fdbe = br_fdb_find_rcu(br, addr, 0);
+	if (!fdbe) {
+		rcu_read_unlock();
+		return NULL;
+	}
+
+	/* Get reference to the port dev */
+	if (!fdbe->dst) {
+		rcu_read_unlock();
+		return NULL;
+	}
+	pdev = fdbe->dst->dev;
+	dev_hold(pdev);
+	rcu_read_unlock();
+
+	return pdev;
+}
+EXPORT_SYMBOL_GPL(br_port_dev_get);
+
+/* Update bridge statistics for bridge packets processed by offload engines */
+void br_dev_update_stats(struct net_device *dev,
+			 struct rtnl_link_stats64 *nlstats)
+{
+	struct pcpu_sw_netstats *tstats;
+
+	/* Is this a bridge? */
+	if (!(dev->priv_flags & IFF_EBRIDGE))
+		return;
+
+	tstats = this_cpu_ptr(dev->tstats);
+
+	u64_stats_update_begin(&tstats->syncp);
+	tstats->rx_packets += nlstats->rx_packets;
+	tstats->rx_bytes += nlstats->rx_bytes;
+	tstats->tx_packets += nlstats->tx_packets;
+	tstats->tx_bytes += nlstats->tx_bytes;
+	u64_stats_update_end(&tstats->syncp);
+}
+EXPORT_SYMBOL_GPL(br_dev_update_stats);
