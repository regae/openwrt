From d2f478751668bc20885723fcf440f37e49a9ae48 Mon Sep 17 00:00:00 2001
From: Tian Yang <tiany@codeaurora.org>
Date: Tue, 26 Jan 2016 16:41:19 -0600
Subject: [PATCH] skb_recycler: add activate/deactivate calls around
 skb_queue_splice_init()

The global recycler lists can change when moving SKBs around, so
let's carefully place the activate and deactivate wrappers around
these calls.

Change-Id: I147b4ae44135dd20b2482e90706301284be401f8
Signed-off-by: Matthew McClintock <mmcclint@codeaurora.org>
Signed-off-by: Casey Chen <kexinc@codeaurora.org>
---
 net/core/skbuff_recycle.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

--- a/net/core/skbuff_recycle.c
+++ b/net/core/skbuff_recycle.c
@@ -58,8 +58,16 @@ inline struct sk_buff *skb_recycler_allo
 		if (unlikely(head == glob_recycler.tail)) {
 			spin_unlock(&glob_recycler.lock);
 		} else {
+			struct sk_buff *gn = glob_recycler.pool[head].next;
+			struct sk_buff *gp = glob_recycler.pool[head].prev;
+
 			/* Move SKBs from global list to CPU pool */
+			skbuff_debugobj_activate(gn);
+			skbuff_debugobj_activate(gp);
 			skb_queue_splice_init(&glob_recycler.pool[head], h);
+			skbuff_debugobj_deactivate(gn);
+			skbuff_debugobj_deactivate(gp);
+
 			head = (head + 1) & SKB_RECYCLE_MAX_SHARED_POOLS_MASK;
 			glob_recycler.head = head;
 			spin_unlock(&glob_recycler.lock);
@@ -140,9 +148,14 @@ inline bool skb_recycler_consume(struct
 		next_tail = (cur_tail + 1) & SKB_RECYCLE_MAX_SHARED_POOLS_MASK;
 		if (next_tail != glob_recycler.head) {
 			struct sk_buff_head *p = &glob_recycler.pool[cur_tail];
+			struct sk_buff *hn = h->next, *hp = h->prev;
 
 			/* Move SKBs from CPU pool to Global pool*/
+			skbuff_debugobj_activate(hp);
+			skbuff_debugobj_activate(hn);
 			skb_queue_splice_init(h, p);
+			skbuff_debugobj_deactivate(hp);
+			skbuff_debugobj_deactivate(hn);
 
 			/* Done with global list init */
 			glob_recycler.tail = next_tail;
