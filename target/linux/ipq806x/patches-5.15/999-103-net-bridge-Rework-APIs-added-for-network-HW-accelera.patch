From e2137fb03985e6525b8f501913a439c1a4afa964 Mon Sep 17 00:00:00 2001
From: Murat Sezgin <msezgin@codeaurora.org>
Date: Wed, 11 Mar 2020 11:17:14 -0700
Subject: [PATCH] net: bridge: Rework APIs added for network HW acceleration

This change is to rework the bridge APIs based on the feedback from the
chromium community

Change-Id: I92a65f1eb26c6700d871f9deb40bccf302cf18eb
Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
---
 include/linux/if_bridge.h |  3 +++
 net/bridge/br_fdb.c       | 21 ++++++++++++++++++++-
 net/bridge/br_if.c        | 22 +++++++---------------
 3 files changed, 30 insertions(+), 16 deletions(-)

--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@ -73,6 +73,9 @@ extern struct net_device *br_port_dev_ge
 extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
 extern void br_dev_update_stats(struct net_device *dev,
 				struct rtnl_link_stats64 *nlstats);
+extern struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
+						     const char *addr,
+						     __u16 vid);
 
 #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
 int br_multicast_list_adjacent(struct net_device *dev,
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -647,7 +647,8 @@ void br_refresh_fdb_entry(struct net_dev
 		return;
 
 	if (!is_valid_ether_addr(addr)) {
-		pr_info("bridge: Attempt to refresh with invalid ether address\n");
+		pr_info("bridge: Attempt to refresh with invalid ether address %pM\n",
+			addr);
 		return;
 	}
 
@@ -657,6 +658,24 @@ void br_refresh_fdb_entry(struct net_dev
 }
 EXPORT_SYMBOL_GPL(br_refresh_fdb_entry);
 
+/* Look up the MAC address in the device's bridge fdb table */
+struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
+					      const char *addr, __u16 vid)
+{
+	struct net_bridge_port *p = br_port_get_rcu(dev);
+	struct net_bridge_fdb_entry *fdb;
+
+	if (!p || p->state == BR_STATE_DISABLED)
+		return NULL;
+
+	rcu_read_lock();
+	fdb = fdb_find_rcu(&p->br->fdb_hash_tbl, addr, vid);
+	rcu_read_unlock();
+
+	return fdb;
+}
+EXPORT_SYMBOL_GPL(br_fdb_has_entry);
+
 static int fdb_to_nud(const struct net_bridge *br,
 			const struct net_bridge_fdb_entry *fdb)
 {
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -797,31 +797,23 @@ struct net_device *br_port_dev_get(struc
 {
 	struct net_bridge_fdb_entry *fdbe;
 	struct net_bridge *br;
-	struct net_device *pdev;
+	struct net_device *netdev = NULL;
 
 	/* Is this a bridge? */
 	if (!(dev->priv_flags & IFF_EBRIDGE))
 		return NULL;
 
-	/* Lookup the fdb entry */
 	br = netdev_priv(dev);
+
+	/* Lookup the fdb entry and get reference to the port dev */
 	rcu_read_lock();
 	fdbe = br_fdb_find_rcu(br, addr, 0);
-	if (!fdbe) {
-		rcu_read_unlock();
-		return NULL;
-	}
-
-	/* Get reference to the port dev */
-	if (!fdbe->dst) {
-		rcu_read_unlock();
-		return NULL;
+	if (fdbe && fdbe->dst) {
+		netdev = fdbe->dst->dev; /* port device */
+		dev_hold(netdev);
 	}
-	pdev = fdbe->dst->dev;
-	dev_hold(pdev);
 	rcu_read_unlock();
-
-	return pdev;
+	return netdev;
 }
 EXPORT_SYMBOL_GPL(br_port_dev_get);
 
