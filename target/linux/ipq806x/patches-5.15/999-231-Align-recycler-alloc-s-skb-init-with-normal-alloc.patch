From 7c909267309a5014e7184859709a69e22a92db10 Mon Sep 17 00:00:00 2001
From: Senthilkumar N L <snlakshm@codeaurora.org>
Date: Sat, 12 Nov 2016 08:26:48 +0530
Subject: [PATCH] Align recycler alloc's skb init with normal alloc

Match up the recycler's skb init with the normal skb allocators
init. Since a couple of fields were not initialized, they seemed
to have some value from their previous usage. This resulted in
some of the network stack's receive code to handle those skbs
incorrectly resulting in a double free of the same skb.

Change-Id: Iad289303360446568cfc98050e262cb7b74576f1
Signed-off-by: Senthilkumar N L <snlakshm@codeaurora.org>
Signed-off-by: Casey Chen <kexinc@codeaurora.org>
---
 net/core/skbuff_recycle.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

--- a/net/core/skbuff_recycle.c
+++ b/net/core/skbuff_recycle.c
@@ -99,6 +99,7 @@ inline struct sk_buff *skb_recycler_allo
 
 	if (likely(skb)) {
 		struct skb_shared_info *shinfo;
+		bool pfmemalloc = skb->pfmemalloc;
 
 		/* We're about to write a large amount to the skb to
 		 * zero most of the structure so prefetch the start
@@ -109,9 +110,10 @@ inline struct sk_buff *skb_recycler_allo
 		prefetchw(shinfo);
 
 		zero_struct(skb, offsetof(struct sk_buff, tail));
-#ifdef NET_SKBUFF_DATA_USES_OFFSET
-		skb->mac_header = ~0U;
-#endif
+		refcount_set(&skb->users, 1);
+		skb->pfmemalloc = pfmemalloc;
+		skb->mac_header = (typeof(skb->mac_header))~0U;
+		skb->transport_header = (typeof(skb->transport_header))~0U;
 		zero_struct(shinfo, offsetof(struct skb_shared_info, dataref));
 		atomic_set(&shinfo->dataref, 1);
 
