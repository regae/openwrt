From 459d4c3e7395e579940da98af680e6c045028931 Mon Sep 17 00:00:00 2001
From: Tian Yang <tiany@codeaurora.org>
Date: Mon, 21 Sep 2015 18:50:13 -0500
Subject: [PATCH] net: skbuff: use debug objects to track skb allocations

* tracks skb allocations and frees and warns / errors if
  re-use occurs
* init/destroy for slab allocations
* activate/deactivate for in use

Change-Id: Ia2dd0c7549d765a282295daf27bee6f99e5c7a43
Signed-off-by: Matthew McClintock <mmcclint@codeaurora.org>
Signed-off-by: Casey Chen <kexinc@codeaurora.org>
Signed-off-by: Tian Yang <tiany@codeaurora.org>
---
 MAINTAINERS             |  1 +
 lib/Kconfig.debug       |  6 ++++
 net/core/Makefile       |  1 +
 net/core/dev.c          |  8 ++++--
 net/core/skbuff.c       |  8 ++++++
 net/core/skbuff_debug.c | 64 +++++++++++++++++++++++++++++++++++++++++
 net/core/skbuff_debug.h | 35 ++++++++++++++++++++++
 7 files changed, 121 insertions(+), 2 deletions(-)
 create mode 100644 net/core/skbuff_debug.c
 create mode 100644 net/core/skbuff_debug.h

--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -147,6 +147,7 @@ SKB RECYCLER SUPPORT
 M:	Casey Chen <kexinc@codeaurora.org>
 S:	Maintained
 F:	net/core/skbuff_recycle.*
+F:	net/core/skbuff_debug.*
 
 3C59X NETWORK DRIVER
 M:	Steffen Klassert <klassert@kernel.org>
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -666,6 +666,12 @@ config DEBUG_OBJECTS_PERCPU_COUNTER
 	  percpu counter routines to track the life time of percpu counter
 	  objects and validate the percpu counter operations.
 
+config DEBUG_OBJECTS_SKBUFF
+	bool "Debug sk_buff allocations"
+	depends on DEBUG_OBJECTS
+	help
+	  Enable this to turn on debugging of sk_buff's (incl. recycler)
+
 config DEBUG_OBJECTS_ENABLE_DEFAULT
 	int "debug_objects bootup default value (0-1)"
 	range 0 1
--- a/net/core/Makefile
+++ b/net/core/Makefile
@@ -39,3 +39,4 @@ obj-$(CONFIG_BPF_SYSCALL) += sock_map.o
 obj-$(CONFIG_BPF_SYSCALL) += bpf_sk_storage.o
 obj-$(CONFIG_OF)	+= of_net.o
 obj-$(CONFIG_SKB_RECYCLER) += skbuff_recycle.o
+obj-$(CONFIG_DEBUG_OBJECTS_SKBUFF) += skbuff_debug.o
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -152,6 +152,7 @@
 #include <linux/once_lite.h>
 
 #include "net-sysfs.h"
+#include "skbuff_debug.h"
 
 #define MAX_GRO_SKBS 8
 
@@ -6334,8 +6335,10 @@ static gro_result_t napi_skb_finish(stru
 		break;
 
 	case GRO_MERGED_FREE:
-		if (NAPI_GRO_CB(skb)->free == NAPI_GRO_FREE_STOLEN_HEAD)
+		if (NAPI_GRO_CB(skb)->free == NAPI_GRO_FREE_STOLEN_HEAD) {
 			napi_skb_free_stolen_head(skb);
+			skbuff_debugobj_deactivate(skb);
+		}
 		else if (skb->fclone != SKB_FCLONE_UNAVAILABLE)
 			__kfree_skb(skb);
 		else
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -84,6 +84,7 @@
 #include "sock_destructor.h"
 
 #include "skbuff_recycle.h"
+#include "skbuff_debug.h"
 
 struct kmem_cache *skbuff_head_cache __ro_after_init;
 static struct kmem_cache *skbuff_fclone_cache __ro_after_init;
@@ -214,6 +215,7 @@ static void __build_skb_around(struct sk
 	shinfo = skb_shinfo(skb);
 	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
+	skbuff_debugobj_init_and_activate(skb);
 
 	skb_set_kcov_handle(skb, kcov_common_handle());
 }
@@ -457,6 +459,7 @@ struct sk_buff *__alloc_skb(unsigned int
 		fclones->skb2.fclone = SKB_FCLONE_CLONE;
 	}
 
+	skbuff_debugobj_init_and_activate(skb);
 	return skb;
 
 nodata:
@@ -734,6 +737,7 @@ void kfree_skbmem(struct sk_buff *skb)
 
 	switch (skb->fclone) {
 	case SKB_FCLONE_UNAVAILABLE:
+		skbuff_debugobj_deactivate(skb);
 		kmem_cache_free(skbuff_head_cache, skb);
 		return;
 
@@ -755,6 +759,7 @@ void kfree_skbmem(struct sk_buff *skb)
 	if (!refcount_dec_and_test(&fclones->fclone_ref))
 		return;
 fastpath:
+	skbuff_debugobj_deactivate(&fclones->skb1);
 	kmem_cache_free(skbuff_fclone_cache, fclones);
 }
 
@@ -1595,6 +1600,7 @@ struct sk_buff *skb_clone(struct sk_buff
 			return NULL;
 
 		n->fclone = SKB_FCLONE_UNAVAILABLE;
+		skbuff_debugobj_init_and_activate(n);
 	}
 
 	return __skb_clone(n, skb);
@@ -5483,6 +5489,7 @@ void kfree_skb_partial(struct sk_buff *s
 	if (head_stolen) {
 		skb_release_head_state(skb);
 		kmem_cache_free(skbuff_head_cache, skb);
+		skbuff_debugobj_deactivate(skb);
 	} else {
 		__kfree_skb(skb);
 	}
--- /dev/null
+++ b/net/core/skbuff_debug.c
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "skbuff_debug.h"
+
+/* skbuff_debugobj_fixup():
+ *	Called when an error is detected in the state machine for
+ *	the objects
+ */
+#if defined(CONFIG_ARM64)
+static bool skbuff_debugobj_fixup(void *addr, enum debug_obj_state state)
+#else
+static int skbuff_debugobj_fixup(void *addr, enum debug_obj_state state)
+#endif
+{
+	WARN(1, "skbuff_debug: state = %d, skb = 0x%p\n", state, addr);
+#ifdef CONFIG_ARM64
+	return true;
+#else
+	return 0;
+#endif
+}
+
+static struct debug_obj_descr skbuff_debug_descr = {
+	.name		= "sk_buff_struct",
+	.fixup_init	= skbuff_debugobj_fixup,
+	.fixup_activate	= skbuff_debugobj_fixup,
+	.fixup_destroy	= skbuff_debugobj_fixup,
+	.fixup_free	= skbuff_debugobj_fixup,
+};
+
+inline void skbuff_debugobj_init_and_activate(struct sk_buff *skb)
+{
+	debug_object_init(skb, &skbuff_debug_descr);
+	debug_object_activate(skb, &skbuff_debug_descr);
+}
+
+inline void skbuff_debugobj_activate(struct sk_buff *skb)
+{
+	debug_object_activate(skb, &skbuff_debug_descr);
+}
+
+inline void skbuff_debugobj_deactivate(struct sk_buff *skb)
+{
+	debug_object_deactivate(skb, &skbuff_debug_descr);
+}
+
+inline void skbuff_debugobj_destroy(struct sk_buff *skb)
+{
+	debug_object_destroy(skb, &skbuff_debug_descr);
+}
--- /dev/null
+++ b/net/core/skbuff_debug.h
@@ -0,0 +1,35 @@
+/* 
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/debugobjects.h>
+
+#ifndef _LINUX_SKBBUFF_DEBUG_OBJECTS
+#define _LINUX_SKBBUFF_DEBUG_OBJECTS
+
+#ifdef CONFIG_DEBUG_OBJECTS_SKBUFF
+void skbuff_debugobj_init_and_activate(struct sk_buff *skb);
+void skbuff_debugobj_activate(struct sk_buff *skb);
+void skbuff_debugobj_deactivate(struct sk_buff *skb);
+void skbuff_debugobj_destroy(struct sk_buff *skb);
+#else
+static inline void skbuff_debugobj_init_and_activate(struct sk_buff *skb) { }
+static inline void skbuff_debugobj_activate(struct sk_buff *skb) { }
+static inline void skbuff_debugobj_deactivate(struct sk_buff *skb) { }
+static inline void skbuff_debugobj_destroy(struct sk_buff *skb) { }
+#endif
+
+#endif /* _LINUX_SKBBUFF_DEBUG_OBJECTS */
