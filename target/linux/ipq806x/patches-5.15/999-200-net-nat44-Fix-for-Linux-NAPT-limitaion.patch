From 79aeb5dab1c0e3f50f8e9f8e2adb1bde9df2c981 Mon Sep 17 00:00:00 2001
From: Apoorv Gupta <apoogupt@codeaurora.org>
Date: Fri, 18 May 2018 16:18:59 +0530
Subject: [PATCH] net: nat44: Fix for Linux NAPT limitaion.

When multiple iptables rules are configured with different port-ranges,
kernel code doesn't fall through to next rule in the chain, even if all
ports available in the current rule are exhausted, so the kernel makes
the flow to share the same snat 5-tuple with other flows.

This fix returns XT_CONTINUE when the tuple returned by get_unique_tuple
is already used. Hence, it will move to next rule available in the chain.

NF_NAT_TRY_NEXT_RULE in netfilter/Kconfig should be set to 'y' prior to
using this fix.

Change-Id: I414887198ecf367c1be97f6f9495b4eb8d36b689
Signed-off-by: Apoorv Gupta <apoogupt@codeaurora.org>
---
 net/netfilter/Kconfig       | 9 +++++++++
 net/netfilter/nf_nat_core.c | 5 +++++
 2 files changed, 14 insertions(+)

--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -456,6 +456,15 @@ config NF_NAT_TFTP
 	depends on NF_CONNTRACK && NF_NAT
 	default NF_NAT && NF_CONNTRACK_TFTP
 
+config NF_NAT_TRY_NEXT_RULE
+	tristate
+	depends on NF_CONNTRACK && NF_NAT
+	default n
+	help
+	  If this option is enabled, the iptables will move on to the
+	  next rule in the chain if a unique tuple is not found for
+	  translation from the current matched rule.
+
 config NF_NAT_REDIRECT
 	bool
 
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@ -601,6 +601,11 @@ nf_nat_setup_info(struct nf_conn *ct,
 
 	get_unique_tuple(&new_tuple, &curr_tuple, range, ct, maniptype);
 
+#if IS_ENABLED(CONFIG_NF_NAT_TRY_NEXT_RULE)
+	if (nf_nat_used_tuple(&new_tuple, ct))
+		return XT_CONTINUE;
+#endif
+
 	if (!nf_ct_tuple_equal(&new_tuple, &curr_tuple)) {
 		struct nf_conntrack_tuple reply;
 
