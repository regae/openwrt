From 5f322031d3bb1f436dcaed7fb294409f7142bb81 Mon Sep 17 00:00:00 2001
From: Apoorv Gupta <apoogupt@codeaurora.org>
Date: Sun, 18 Aug 2019 23:18:04 +0530
Subject: [PATCH] net: Setting skb input interface to vxlan during
 encapsulation.

Setting skb_iif to vxlan when encapsulating with IP/IPv6 header.
Also removed the is_vxlan_dev() API support, as it can be replaced
by in-built API netif_is_vxlan().

Change-Id: I480d15b2ef2e91038676c620a98217e35e29b002
Signed-off-by: Apoorv Gupta <apoogupt@codeaurora.org>
---
 drivers/net/vxlan/vxlan_core.c       |  6 ++++++
 include/net/vxlan.h       | 15 ++++-----------
 net/ipv4/ip_tunnel_core.c | 10 +++++++++-
 3 files changed, 19 insertions(+), 12 deletions(-)

--- a/drivers/net/vxlan/vxlan_core.c
+++ b/drivers/net/vxlan/vxlan_core.c
@@ -2781,6 +2781,9 @@ static void vxlan_xmit_one(struct sk_buf
 			goto out_unlock;
 		}
 
+		/* Reset the skb_iif to Tunnels interface index */
+		skb->skb_iif = dev->ifindex;
+
 		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
 		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
 		err = vxlan_build_skb(skb, ndst, sizeof(struct iphdr),
@@ -2852,6 +2855,9 @@ static void vxlan_xmit_one(struct sk_buf
 		if (err < 0)
 			goto tx_error;
 
+		/* Reset the skb_iif to Tunnels interface index */
+		skb->skb_iif = dev->ifindex;
+
 		udp_tunnel6_xmit_skb(ndst, sock6->sock->sk, skb, dev,
 				     &local_ip.sin6.sin6_addr,
 				     &dst->sin6.sin6_addr, tos, ttl,
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -395,19 +395,12 @@ static inline __be32 vxlan_compute_rco(u
 }
 
 /*
- * is_vxlan_dev()
- *	Check if it is a VxLAN netdevice.
+ * vxlan_get_vni()
+ *	Returns the vni corresponding to tunnel
  */
-static inline bool is_vxlan_dev(const struct net_device *dev)
+static inline u32 vxlan_get_vni(struct vxlan_dev *vxlan_tun)
 {
-	if (!dev)
-		return false;
-
-	if ((dev->dev.type) &&
-		!strncmp(dev->dev.type->name, "vxlan", sizeof("vxlan"))) {
-		return true;
-	}
-	return false;
+	return be32_to_cpu(vxlan_tun->cfg.vni);
 }
 
 static inline unsigned short vxlan_get_sk_family(struct vxlan_sock *vs)
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@ -55,6 +55,7 @@ void iptunnel_xmit(struct sock *sk, stru
 	struct net *net = dev_net(rt->dst.dev);
 	struct net_device *dev = skb->dev;
 	struct iphdr *iph;
+	struct net_device *in_dev = NULL;
 	int err;
 	int skb_iif;
 
@@ -83,8 +84,14 @@ void iptunnel_xmit(struct sock *sk, stru
 	iph->ttl	=	ttl;
 	__ip_select_ident(net, iph, skb_shinfo(skb)->gso_segs ?: 1);
 
-	if (proto == IPPROTO_IPV6 || proto == IPPROTO_GRE)
+	/* Get input interface */
+	if (skb_iif) {
+		in_dev = __dev_get_by_index(&init_net, skb_iif);
+	}
+
+	if (proto == IPPROTO_IPV6 || proto == IPPROTO_GRE || netif_is_vxlan(in_dev)) {
 		skb->skb_iif = skb_iif;
+	}
 
 	err = ip_local_out(net, sk, skb);
 
