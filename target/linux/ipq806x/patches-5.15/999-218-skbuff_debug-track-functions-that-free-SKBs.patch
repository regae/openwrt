From 395303f61c8c21e341dbff4d7f7cc2f9c23feac8 Mon Sep 17 00:00:00 2001
From: Tian Yang <tiany@codeaurora.org>
Date: Thu, 1 Oct 2015 16:31:33 -0500
Subject: [PATCH] skbuff_debug: track functions that free SKBs

This adds a member to struct skbuff if
CONFIG_DEBUG_OBJECTS_SKBUFF is turned on that tracks
the caller that last free'd the SKB.

This should work for SLAB and SKB recycler free since this
element of the SKB should not get overwritten when allocated
from either pool of objects.

Performance info for before/after:

Before:

 speed was 53.45 Mbit/s
 cycles = 97974050028 (per pkt = 35368.7482818)
 instructions = 26722549696 (per pkt = 9646.87213988)
 dcache_misses = 512380452 (per pkt = 184.969950983)
 icache_misses = 1268005369 (per pkt = 457.75144238)

After:

 speed was 48.91 Mbit/s
 cycles = 98737753294 (per pkt = 38614.9009095)
 instructions = 25770915740 (per pkt = 10078.6307613)
 dcache_misses = 589106068 (per pkt = 230.39082501)
 icache_misses = 1146428790 (per pkt = 448.351645128)

Change-Id: Ie9e854015dc040fc30b97f89dd0663601b8f0344
Signed-off-by: Matthew McClintock <mmcclint@codeaurora.org>
Signed-off-by: Casey Chen <kexinc@codeaurora.org>
---
 include/linux/skbuff.h  |  4 +++
 net/core/skbuff_debug.c | 58 +++++++++++++++++++++++++++++++++++++----
 2 files changed, 57 insertions(+), 5 deletions(-)

--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -985,6 +985,10 @@ struct sk_buff {
 	/* only useable after checking ->active_extensions != 0 */
 	struct skb_ext		*extensions;
 #endif
+
+#ifdef CONFIG_DEBUG_OBJECTS_SKBUFF
+	void			*free_addr;
+#endif
 };
 
 #ifdef __KERNEL__
--- a/net/core/skbuff_debug.c
+++ b/net/core/skbuff_debug.c
@@ -14,6 +14,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <asm/stacktrace.h>
+#include <linux/module.h>
+
 #include "skbuff_debug.h"
 
 static int skbuff_debugobj_enabled __read_mostly = 1;
@@ -28,8 +31,10 @@ static bool skbuff_debugobj_fixup(void *
 static int skbuff_debugobj_fixup(void *addr, enum debug_obj_state state)
 #endif
 {
+	struct sk_buff *skb = (struct sk_buff *)addr;
 	ftrace_dump(DUMP_ALL);
-	WARN(1, "skbuff_debug: state = %d, skb = 0x%p\n", state, addr);
+        WARN(1, "skbuff_debug: state = %d, skb = 0x%p last free = %pS\n",
+             state, skb, skb->free_addr);
 #ifdef CONFIG_ARM64
 	return true;
 #else
@@ -56,8 +61,8 @@ inline void skbuff_debugobj_activate(str
 
 	if (ret) {
 		ftrace_dump(DUMP_ALL);
-		WARN(1, "skb_debug: failed to activate err = %d skb = 0x%p\n",
-		     ret, skb);
+		WARN(1, "skb_debug: failed to activate err = %d skb = 0x%p last free=%pS\n",
+		     ret, skb, skb->free_addr);
 	}
 }
 
@@ -70,6 +75,48 @@ inline void skbuff_debugobj_init_and_act
 	skbuff_debugobj_activate(skb);
 }
 
+static int skbuff_debugobj_walkstack(struct stackframe *frame, void *d)
+{
+	u32 *pc = d;
+
+	*pc = frame->pc;
+
+	/* walk to outside kernel address space (e.g. module)
+	 * for the time being, need a whitelist here in the
+	 * future most likely
+	 */
+	if (is_module_text_address(*pc))
+		return -1;
+
+	return 0;
+}
+
+#ifdef CONFIG_ARM
+static void *skbuff_debugobj_get_free_addr(void)
+{
+	struct stackframe frame;
+
+	register unsigned long current_sp asm ("sp");
+	void *ret = NULL;
+
+	frame.fp = (unsigned long)__builtin_frame_address(0);
+	frame.sp = current_sp;
+	frame.lr = (unsigned long)__builtin_return_address(0);
+	frame.pc = (unsigned long)skbuff_debugobj_get_free_addr;
+
+	walk_stackframe(&frame, skbuff_debugobj_walkstack, &ret);
+
+	return ret;
+}
+#else
+#error
+static void *skbuff_debugobj_get_free_addr(void)
+{
+	/* not supported */
+	return 0xdeadbeef;
+}
+#endif
+
 inline void skbuff_debugobj_deactivate(struct sk_buff *skb)
 {
 	int obj_state;
@@ -81,12 +128,13 @@ inline void skbuff_debugobj_deactivate(s
 
 	if (obj_state == ODEBUG_STATE_ACTIVE) {
 		debug_object_deactivate(skb, &skbuff_debug_descr);
+		skb->free_addr = skbuff_debugobj_get_free_addr();
 		return;
 	}
 
 	ftrace_dump(DUMP_ALL);
-	WARN(1, "skbuff_debug: deactivating inactive object skb 0x%p state=%d\n",
-	     skb, obj_state);
+	WARN(1, "skbuff_debug: deactivating inactive object skb=0x%p state=%d last free=%pS\n",
+	     skb, obj_state, skb->free_addr);
 }
 
 inline void skbuff_debugobj_destroy(struct sk_buff *skb)
