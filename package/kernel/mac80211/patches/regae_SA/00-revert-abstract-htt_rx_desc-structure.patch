revert 6bae9de622d3ef4805aba40e763eb4b0975c4f6d
ath10k: abstract htt_rx_desc structure
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -81,7 +81,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA988X_BOARD_DATA_SZ,
 			.board_ext_size = QCA988X_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca988x_ops,
 		.decap_align_bytes = 4,
 		.spectral_bin_discard = 0,
@@ -121,7 +120,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA988X_BOARD_DATA_SZ,
 			.board_ext_size = QCA988X_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca988x_ops,
 		.decap_align_bytes = 4,
 		.spectral_bin_discard = 0,
@@ -163,7 +161,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA9887_BOARD_DATA_SZ,
 			.board_ext_size = QCA9887_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca988x_ops,
 		.decap_align_bytes = 4,
 		.spectral_bin_discard = 0,
@@ -203,7 +200,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA6174_BOARD_DATA_SZ,
 			.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca6174_sdio_ops,
 		.hw_clk = qca6174_clk,
 		.target_cpu_freq = 176000000,
@@ -239,7 +235,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA6174_BOARD_DATA_SZ,
 			.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca988x_ops,
 		.decap_align_bytes = 4,
 		.spectral_bin_discard = 0,
@@ -279,7 +274,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA6174_BOARD_DATA_SZ,
 			.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca988x_ops,
 		.decap_align_bytes = 4,
 		.spectral_bin_discard = 0,
@@ -319,7 +313,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA6174_BOARD_DATA_SZ,
 			.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca988x_ops,
 		.decap_align_bytes = 4,
 		.spectral_bin_discard = 0,
@@ -360,7 +353,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA6174_BOARD_DATA_SZ,
 			.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca6174_ops,
 		.hw_clk = qca6174_clk,
 		.target_cpu_freq = 176000000,
@@ -410,7 +402,6 @@ static const struct ath10k_hw_params ath
 			.board_ext_size = QCA99X0_BOARD_EXT_DATA_SZ,
 		},
 		.sw_decrypt_mcast_mgmt = true,
-		.rx_desc_ops = &qca99x0_rx_desc_ops,
 		.hw_ops = &qca99x0_ops,
 		.decap_align_bytes = 1,
 		.spectral_bin_discard = 4,
@@ -460,7 +451,6 @@ static const struct ath10k_hw_params ath
 			.ext_board_size = QCA99X0_EXT_BOARD_DATA_SZ,
 		},
 		.sw_decrypt_mcast_mgmt = true,
-		.rx_desc_ops = &qca99x0_rx_desc_ops,
 		.hw_ops = &qca99x0_ops,
 		.decap_align_bytes = 1,
 		.spectral_bin_discard = 12,
@@ -511,7 +501,6 @@ static const struct ath10k_hw_params ath
 			.board_ext_size = QCA99X0_BOARD_EXT_DATA_SZ,
 		},
 		.sw_decrypt_mcast_mgmt = true,
-		.rx_desc_ops = &qca99x0_rx_desc_ops,
 		.hw_ops = &qca99x0_ops,
 		.decap_align_bytes = 1,
 		.spectral_bin_discard = 12,
@@ -555,7 +544,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA9377_BOARD_DATA_SZ,
 			.board_ext_size = QCA9377_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca988x_ops,
 		.decap_align_bytes = 4,
 		.spectral_bin_discard = 0,
@@ -595,7 +583,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA9377_BOARD_DATA_SZ,
 			.board_ext_size = QCA9377_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca6174_ops,
 		.hw_clk = qca6174_clk,
 		.target_cpu_freq = 176000000,
@@ -637,7 +624,6 @@ static const struct ath10k_hw_params ath
 			.board_size = QCA9377_BOARD_DATA_SZ,
 			.board_ext_size = QCA9377_BOARD_EXT_DATA_SZ,
 		},
-		.rx_desc_ops = &qca988x_rx_desc_ops,
 		.hw_ops = &qca6174_ops,
 		.hw_clk = qca6174_clk,
 		.target_cpu_freq = 176000000,
@@ -677,7 +663,6 @@ static const struct ath10k_hw_params ath
 			.board_ext_size = QCA4019_BOARD_EXT_DATA_SZ,
 		},
 		.sw_decrypt_mcast_mgmt = true,
-		.rx_desc_ops = &qca99x0_rx_desc_ops,
 		.hw_ops = &qca99x0_ops,
 		.decap_align_bytes = 1,
 		.spectral_bin_discard = 4,
@@ -713,7 +698,6 @@ static const struct ath10k_hw_params ath
 			.dir = WCN3990_HW_1_0_FW_DIR,
 		},
 		.sw_decrypt_mcast_mgmt = true,
-		.rx_desc_ops = &wcn3990_rx_desc_ops,
 		.hw_ops = &wcn3990_ops,
 		.decap_align_bytes = 1,
 		.num_peers = TARGET_HL_TLV_NUM_PEERS,
--- a/drivers/net/wireless/ath/ath10k/htt.c
+++ b/drivers/net/wireless/ath/ath10k/htt.c
@@ -131,159 +131,6 @@ static const enum htt_t2h_msg_type htt_1
 				HTT_T2H_MSG_TYPE_PEER_STATS,
 };
 
-const struct ath10k_htt_rx_desc_ops qca988x_rx_desc_ops = {
-	.rx_desc_size = sizeof(struct htt_rx_desc_v1),
-	.rx_desc_msdu_payload_offset = offsetof(struct htt_rx_desc_v1, msdu_payload)
-};
-
-static int ath10k_qca99x0_rx_desc_get_l3_pad_bytes(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc = container_of(rxd,
-						      struct htt_rx_desc_v1,
-						      base);
-
-	return MS(__le32_to_cpu(rx_desc->msdu_end.qca99x0.info1),
-		  RX_MSDU_END_INFO1_L3_HDR_PAD);
-}
-
-static bool ath10k_qca99x0_rx_desc_msdu_limit_error(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc = container_of(rxd,
-						      struct htt_rx_desc_v1,
-						      base);
-
-	return !!(rx_desc->msdu_end.common.info0 &
-		  __cpu_to_le32(RX_MSDU_END_INFO0_MSDU_LIMIT_ERR));
-}
-
-const struct ath10k_htt_rx_desc_ops qca99x0_rx_desc_ops = {
-	.rx_desc_size = sizeof(struct htt_rx_desc_v1),
-	.rx_desc_msdu_payload_offset = offsetof(struct htt_rx_desc_v1, msdu_payload),
-
-	.rx_desc_get_l3_pad_bytes = ath10k_qca99x0_rx_desc_get_l3_pad_bytes,
-	.rx_desc_get_msdu_limit_error = ath10k_qca99x0_rx_desc_msdu_limit_error,
-};
-
-static void ath10k_rx_desc_wcn3990_get_offsets(struct htt_rx_ring_rx_desc_offsets *off)
-{
-#define desc_offset(x) (offsetof(struct htt_rx_desc_v2, x) / 4)
-	off->mac80211_hdr_offset = __cpu_to_le16(desc_offset(rx_hdr_status));
-	off->msdu_payload_offset = __cpu_to_le16(desc_offset(msdu_payload));
-	off->ppdu_start_offset = __cpu_to_le16(desc_offset(ppdu_start));
-	off->ppdu_end_offset = __cpu_to_le16(desc_offset(ppdu_end));
-	off->mpdu_start_offset = __cpu_to_le16(desc_offset(mpdu_start));
-	off->mpdu_end_offset = __cpu_to_le16(desc_offset(mpdu_end));
-	off->msdu_start_offset = __cpu_to_le16(desc_offset(msdu_start));
-	off->msdu_end_offset = __cpu_to_le16(desc_offset(msdu_end));
-	off->rx_attention_offset = __cpu_to_le16(desc_offset(attention));
-	off->frag_info_offset = __cpu_to_le16(desc_offset(frag_info));
-#undef desc_offset
-}
-
-static struct htt_rx_desc *
-ath10k_rx_desc_wcn3990_from_raw_buffer(void *buff)
-{
-	return &((struct htt_rx_desc_v2 *)buff)->base;
-}
-
-static struct rx_attention *
-ath10k_rx_desc_wcn3990_get_attention(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return &rx_desc->attention;
-}
-
-static struct rx_frag_info_common *
-ath10k_rx_desc_wcn3990_get_frag_info(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return &rx_desc->frag_info.common;
-}
-
-static struct rx_mpdu_start *
-ath10k_rx_desc_wcn3990_get_mpdu_start(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return &rx_desc->mpdu_start;
-}
-
-static struct rx_mpdu_end *
-ath10k_rx_desc_wcn3990_get_mpdu_end(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return &rx_desc->mpdu_end;
-}
-
-static struct rx_msdu_start_common *
-ath10k_rx_desc_wcn3990_get_msdu_start(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return &rx_desc->msdu_start.common;
-}
-
-static struct rx_msdu_end_common *
-ath10k_rx_desc_wcn3990_get_msdu_end(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return &rx_desc->msdu_end.common;
-}
-
-static struct rx_ppdu_start *
-ath10k_rx_desc_wcn3990_get_ppdu_start(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return &rx_desc->ppdu_start;
-}
-
-static struct rx_ppdu_end_common *
-ath10k_rx_desc_wcn3990_get_ppdu_end(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return &rx_desc->ppdu_end.common;
-}
-
-static u8 *
-ath10k_rx_desc_wcn3990_get_rx_hdr_status(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return rx_desc->rx_hdr_status;
-}
-
-static u8 *
-ath10k_rx_desc_wcn3990_get_msdu_payload(struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v2 *rx_desc = container_of(rxd, struct htt_rx_desc_v2, base);
-
-	return rx_desc->msdu_payload;
-}
-
-const struct ath10k_htt_rx_desc_ops wcn3990_rx_desc_ops = {
-	.rx_desc_size = sizeof(struct htt_rx_desc_v2),
-	.rx_desc_msdu_payload_offset = offsetof(struct htt_rx_desc_v2, msdu_payload),
-
-	.rx_desc_from_raw_buffer = ath10k_rx_desc_wcn3990_from_raw_buffer,
-	.rx_desc_get_offsets = ath10k_rx_desc_wcn3990_get_offsets,
-	.rx_desc_get_attention = ath10k_rx_desc_wcn3990_get_attention,
-	.rx_desc_get_frag_info = ath10k_rx_desc_wcn3990_get_frag_info,
-	.rx_desc_get_mpdu_start = ath10k_rx_desc_wcn3990_get_mpdu_start,
-	.rx_desc_get_mpdu_end = ath10k_rx_desc_wcn3990_get_mpdu_end,
-	.rx_desc_get_msdu_start = ath10k_rx_desc_wcn3990_get_msdu_start,
-	.rx_desc_get_msdu_end = ath10k_rx_desc_wcn3990_get_msdu_end,
-	.rx_desc_get_ppdu_start = ath10k_rx_desc_wcn3990_get_ppdu_start,
-	.rx_desc_get_ppdu_end = ath10k_rx_desc_wcn3990_get_ppdu_end,
-	.rx_desc_get_rx_hdr_status = ath10k_rx_desc_wcn3990_get_rx_hdr_status,
-	.rx_desc_get_msdu_payload = ath10k_rx_desc_wcn3990_get_msdu_payload,
-};
-
 int ath10k_htt_connect(struct ath10k_htt *htt)
 {
 	struct ath10k_htc_svc_conn_req conn_req;
--- a/drivers/net/wireless/ath/ath10k/htt.h
+++ b/drivers/net/wireless/ath/ath10k/htt.h
@@ -244,7 +244,14 @@ enum htt_rx_ring_flags {
 #define HTT_RX_RING_FILL_LEVEL (((HTT_RX_RING_SIZE) / 2) - 1)
 #define HTT_RX_RING_FILL_LEVEL_DUAL_MAC (HTT_RX_RING_SIZE - 1)
 
-struct htt_rx_ring_rx_desc_offsets {
+struct htt_rx_ring_setup_ring32 {
+	__le32 fw_idx_shadow_reg_paddr;
+	__le32 rx_ring_base_paddr;
+	__le16 rx_ring_len; /* in 4-byte words */
+	__le16 rx_ring_bufsize; /* rx skb size - in bytes */
+	__le16 flags; /* %HTT_RX_RING_FLAGS_ */
+	__le16 fw_idx_init_val;
+
 	/* the following offsets are in 4-byte units */
 	__le16 mac80211_hdr_offset;
 	__le16 msdu_payload_offset;
@@ -258,17 +265,6 @@ struct htt_rx_ring_rx_desc_offsets {
 	__le16 frag_info_offset;
 } __packed;
 
-struct htt_rx_ring_setup_ring32 {
-	__le32 fw_idx_shadow_reg_paddr;
-	__le32 rx_ring_base_paddr;
-	__le16 rx_ring_len; /* in 4-byte words */
-	__le16 rx_ring_bufsize; /* rx skb size - in bytes */
-	__le16 flags; /* %HTT_RX_RING_FLAGS_ */
-	__le16 fw_idx_init_val;
-
-	struct htt_rx_ring_rx_desc_offsets offsets;
-} __packed;
-
 struct htt_rx_ring_setup_ring64 {
 	__le64 fw_idx_shadow_reg_paddr;
 	__le64 rx_ring_base_paddr;
@@ -277,7 +273,17 @@ struct htt_rx_ring_setup_ring64 {
 	__le16 flags; /* %HTT_RX_RING_FLAGS_ */
 	__le16 fw_idx_init_val;
 
-	struct htt_rx_ring_rx_desc_offsets offsets;
+	/* the following offsets are in 4-byte units */
+	__le16 mac80211_hdr_offset;
+	__le16 msdu_payload_offset;
+	__le16 ppdu_start_offset;
+	__le16 ppdu_end_offset;
+	__le16 mpdu_start_offset;
+	__le16 mpdu_end_offset;
+	__le16 msdu_start_offset;
+	__le16 msdu_end_offset;
+	__le16 rx_attention_offset;
+	__le16 frag_info_offset;
 } __packed;
 
 struct htt_rx_ring_setup_hdr {
@@ -2073,22 +2079,12 @@ static inline bool ath10k_htt_rx_proc_rx
 	return htt->rx_ops->htt_rx_proc_rx_frag_ind(htt, rx, skb);
 }
 
-/* the driver strongly assumes that the rx header status be 64 bytes long,
- * so all possible rx_desc structures must respect this assumption.
- */
 #define RX_HTT_HDR_STATUS_LEN 64
 
-/* The rx descriptor structure layout is programmed via rx ring setup
+/* This structure layout is programmed via rx ring setup
  * so that FW knows how to transfer the rx descriptor to the host.
- * Unfortunately, though, QCA6174's firmware doesn't currently behave correctly
- * when modifying the structure layout of the rx descriptor beyond what it expects
- * (even if it correctly programmed during the rx ring setup).
- * Therefore we must keep two different memory layouts, abstract the rx descriptor
- * representation and use ath10k_rx_desc_ops
- * for correctly accessing rx descriptor data.
+ * Buffers like this are placed on the rx ring.
  */
-
-/* base struct used for abstracting the rx descritor representation */
 struct htt_rx_desc {
 	union {
 		/* This field is filled on the host using the msdu buffer
@@ -2097,13 +2093,6 @@ struct htt_rx_desc {
 		struct fw_rx_desc_base fw_desc;
 		u32 pad;
 	} __packed;
-} __packed;
-
-/* rx descriptor for wcn3990 and possibly extensible for newer cards
- * Buffers like this are placed on the rx ring.
- */
-struct htt_rx_desc_v2 {
-	struct htt_rx_desc base;
 	struct {
 		struct rx_attention attention;
 		struct rx_frag_info frag_info;
@@ -2118,240 +2107,6 @@ struct htt_rx_desc_v2 {
 	u8 msdu_payload[];
 };
 
-/* QCA6174, QCA988x, QCA99x0 dedicated rx descriptor to make sure their firmware
- * works correctly. We keep a single rx descriptor for all these three
- * families of cards because from tests it seems to be the most stable solution,
- * e.g. having a rx descriptor only for QCA6174 seldom caused firmware crashes
- * during some tests.
- * Buffers like this are placed on the rx ring.
- */
-struct htt_rx_desc_v1 {
-	struct htt_rx_desc base;
-	struct {
-		struct rx_attention attention;
-		struct rx_frag_info_v1 frag_info;
-		struct rx_mpdu_start mpdu_start;
-		struct rx_msdu_start_v1 msdu_start;
-		struct rx_msdu_end_v1 msdu_end;
-		struct rx_mpdu_end mpdu_end;
-		struct rx_ppdu_start ppdu_start;
-		struct rx_ppdu_end_v1 ppdu_end;
-	} __packed;
-	u8 rx_hdr_status[RX_HTT_HDR_STATUS_LEN];
-	u8 msdu_payload[];
-};
-
-/* rx_desc abstraction */
-struct ath10k_htt_rx_desc_ops {
-	/* These fields are mandatory, they must be specified in any instance */
-
-	/* sizeof() of the rx_desc structure used by this hw */
-	size_t rx_desc_size;
-
-	/* offset of msdu_payload inside the rx_desc structure used by this hw */
-	size_t rx_desc_msdu_payload_offset;
-
-	/* These fields are options.
-	 * When a field is not provided the default implementation gets used
-	 * (see the ath10k_rx_desc_* operations below for more info about the defaults)
-	 */
-	bool (*rx_desc_get_msdu_limit_error)(struct htt_rx_desc *rxd);
-	int (*rx_desc_get_l3_pad_bytes)(struct htt_rx_desc *rxd);
-
-	/* Safely cast from a void* buffer containing an rx descriptor
-	 * to the proper rx_desc structure
-	 */
-	struct htt_rx_desc *(*rx_desc_from_raw_buffer)(void *buff);
-
-	void (*rx_desc_get_offsets)(struct htt_rx_ring_rx_desc_offsets *offs);
-	struct rx_attention *(*rx_desc_get_attention)(struct htt_rx_desc *rxd);
-	struct rx_frag_info_common *(*rx_desc_get_frag_info)(struct htt_rx_desc *rxd);
-	struct rx_mpdu_start *(*rx_desc_get_mpdu_start)(struct htt_rx_desc *rxd);
-	struct rx_mpdu_end *(*rx_desc_get_mpdu_end)(struct htt_rx_desc *rxd);
-	struct rx_msdu_start_common *(*rx_desc_get_msdu_start)(struct htt_rx_desc *rxd);
-	struct rx_msdu_end_common *(*rx_desc_get_msdu_end)(struct htt_rx_desc *rxd);
-	struct rx_ppdu_start *(*rx_desc_get_ppdu_start)(struct htt_rx_desc *rxd);
-	struct rx_ppdu_end_common *(*rx_desc_get_ppdu_end)(struct htt_rx_desc *rxd);
-	u8 *(*rx_desc_get_rx_hdr_status)(struct htt_rx_desc *rxd);
-	u8 *(*rx_desc_get_msdu_payload)(struct htt_rx_desc *rxd);
-};
-
-extern const struct ath10k_htt_rx_desc_ops qca988x_rx_desc_ops;
-extern const struct ath10k_htt_rx_desc_ops qca99x0_rx_desc_ops;
-extern const struct ath10k_htt_rx_desc_ops wcn3990_rx_desc_ops;
-
-static inline int
-ath10k_htt_rx_desc_get_l3_pad_bytes(struct ath10k_hw_params *hw, struct htt_rx_desc *rxd)
-{
-	if (hw->rx_desc_ops->rx_desc_get_l3_pad_bytes)
-		return hw->rx_desc_ops->rx_desc_get_l3_pad_bytes(rxd);
-	return 0;
-}
-
-static inline bool
-ath10k_htt_rx_desc_msdu_limit_error(struct ath10k_hw_params *hw, struct htt_rx_desc *rxd)
-{
-	if (hw->rx_desc_ops->rx_desc_get_msdu_limit_error)
-		return hw->rx_desc_ops->rx_desc_get_msdu_limit_error(rxd);
-	return false;
-}
-
-/* The default implementation of all these getters is using the old rx_desc,
- * so that it is easier to define the ath10k_htt_rx_desc_ops instances.
- * But probably, if new wireless cards must be supported, it would be better
- * to switch the default implementation to the new rx_desc, since this would
- * make the extension easier .
- */
-static inline struct htt_rx_desc *
-ath10k_htt_rx_desc_from_raw_buffer(struct ath10k_hw_params *hw,	void *buff)
-{
-	if (hw->rx_desc_ops->rx_desc_from_raw_buffer)
-		return hw->rx_desc_ops->rx_desc_from_raw_buffer(buff);
-	return &((struct htt_rx_desc_v1 *)buff)->base;
-}
-
-static inline void
-ath10k_htt_rx_desc_get_offsets(struct ath10k_hw_params *hw,
-			       struct htt_rx_ring_rx_desc_offsets *off)
-{
-	if (hw->rx_desc_ops->rx_desc_get_offsets) {
-		hw->rx_desc_ops->rx_desc_get_offsets(off);
-	} else {
-#define	desc_offset(x) (offsetof(struct	htt_rx_desc_v1, x)	/ 4)
-		off->mac80211_hdr_offset = __cpu_to_le16(desc_offset(rx_hdr_status));
-		off->msdu_payload_offset = __cpu_to_le16(desc_offset(msdu_payload));
-		off->ppdu_start_offset = __cpu_to_le16(desc_offset(ppdu_start));
-		off->ppdu_end_offset = __cpu_to_le16(desc_offset(ppdu_end));
-		off->mpdu_start_offset = __cpu_to_le16(desc_offset(mpdu_start));
-		off->mpdu_end_offset = __cpu_to_le16(desc_offset(mpdu_end));
-		off->msdu_start_offset = __cpu_to_le16(desc_offset(msdu_start));
-		off->msdu_end_offset = __cpu_to_le16(desc_offset(msdu_end));
-		off->rx_attention_offset = __cpu_to_le16(desc_offset(attention));
-		off->frag_info_offset =	__cpu_to_le16(desc_offset(frag_info));
-#undef desc_offset
-	}
-}
-
-static inline struct rx_attention *
-ath10k_htt_rx_desc_get_attention(struct	ath10k_hw_params *hw, struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_attention)
-		return hw->rx_desc_ops->rx_desc_get_attention(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return &rx_desc->attention;
-}
-
-static inline struct rx_frag_info_common *
-ath10k_htt_rx_desc_get_frag_info(struct	ath10k_hw_params *hw, struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_frag_info)
-		return hw->rx_desc_ops->rx_desc_get_frag_info(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return &rx_desc->frag_info.common;
-}
-
-static inline struct rx_mpdu_start *
-ath10k_htt_rx_desc_get_mpdu_start(struct ath10k_hw_params *hw, struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_mpdu_start)
-		return hw->rx_desc_ops->rx_desc_get_mpdu_start(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return &rx_desc->mpdu_start;
-}
-
-static inline struct rx_mpdu_end *
-ath10k_htt_rx_desc_get_mpdu_end(struct ath10k_hw_params	*hw, struct htt_rx_desc	*rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_mpdu_end)
-		return hw->rx_desc_ops->rx_desc_get_mpdu_end(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return &rx_desc->mpdu_end;
-}
-
-static inline struct rx_msdu_start_common *
-ath10k_htt_rx_desc_get_msdu_start(struct ath10k_hw_params *hw, struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_msdu_start)
-		return hw->rx_desc_ops->rx_desc_get_msdu_start(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return &rx_desc->msdu_start.common;
-}
-
-static inline struct rx_msdu_end_common	*
-ath10k_htt_rx_desc_get_msdu_end(struct ath10k_hw_params	*hw, struct htt_rx_desc	*rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_msdu_end)
-		return hw->rx_desc_ops->rx_desc_get_msdu_end(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return &rx_desc->msdu_end.common;
-}
-
-static inline struct rx_ppdu_start *
-ath10k_htt_rx_desc_get_ppdu_start(struct ath10k_hw_params *hw, struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_ppdu_start)
-		return hw->rx_desc_ops->rx_desc_get_ppdu_start(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return &rx_desc->ppdu_start;
-}
-
-static inline struct rx_ppdu_end_common	*
-ath10k_htt_rx_desc_get_ppdu_end(struct ath10k_hw_params	*hw, struct htt_rx_desc	*rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_ppdu_end)
-		return hw->rx_desc_ops->rx_desc_get_ppdu_end(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return &rx_desc->ppdu_end.common;
-}
-
-static inline u8 *
-ath10k_htt_rx_desc_get_rx_hdr_status(struct ath10k_hw_params *hw, struct htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_rx_hdr_status)
-		return hw->rx_desc_ops->rx_desc_get_rx_hdr_status(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return rx_desc->rx_hdr_status;
-}
-
-static inline u8 *
-ath10k_htt_rx_desc_get_msdu_payload(struct ath10k_hw_params *hw, struct	htt_rx_desc *rxd)
-{
-	struct htt_rx_desc_v1 *rx_desc;
-
-	if (hw->rx_desc_ops->rx_desc_get_msdu_payload)
-		return hw->rx_desc_ops->rx_desc_get_msdu_payload(rxd);
-
-	rx_desc = container_of(rxd, struct htt_rx_desc_v1, base);
-	return rx_desc->msdu_payload;
-}
-
 #define HTT_RX_DESC_HL_INFO_SEQ_NUM_MASK           0x00000fff
 #define HTT_RX_DESC_HL_INFO_SEQ_NUM_LSB            0
 #define HTT_RX_DESC_HL_INFO_ENCRYPTED_MASK         0x00001000
@@ -2385,14 +2140,7 @@ struct htt_rx_chan_info {
  * rounded up to a cache line size.
  */
 #define HTT_RX_BUF_SIZE 2048
-
-/* The HTT_RX_MSDU_SIZE can't be statically computed anymore,
- * because it depends on the underlying device rx_desc representation
- */
-static inline int ath10k_htt_rx_msdu_size(struct ath10k_hw_params *hw)
-{
-	return HTT_RX_BUF_SIZE - (int)hw->rx_desc_ops->rx_desc_size;
-}
+#define HTT_RX_MSDU_SIZE (HTT_RX_BUF_SIZE - (int)sizeof(struct htt_rx_desc))
 
 /* Refill a bunch of RX buffers for each refill round so that FW/HW can handle
  * aggregated traffic more nicely.
--- a/drivers/net/wireless/ath/ath10k/htt_rx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
@@ -21,10 +21,7 @@
 
 #define HTT_RX_RING_REFILL_RESCHED_MS 5
 
-/* shortcut to interpret a raw memory buffer as a rx descriptor */
-#define HTT_RX_BUF_TO_RX_DESC(hw, buf) ath10k_htt_rx_desc_from_raw_buffer(hw, buf)
-
-static int ath10k_htt_rx_get_csum_state(struct ath10k_hw_params *hw, struct sk_buff *skb);
+static int ath10k_htt_rx_get_csum_state(struct sk_buff *skb);
 
 static struct sk_buff *
 ath10k_htt_rx_find_skb_paddr(struct ath10k *ar, u64 paddr)
@@ -131,7 +128,6 @@ static void *ath10k_htt_get_vaddr_ring_6
 
 static int __ath10k_htt_rx_ring_fill_n(struct ath10k_htt *htt, int num)
 {
-	struct ath10k_hw_params *hw = &htt->ar->hw_params;
 	struct htt_rx_desc *rx_desc;
 	struct ath10k_skb_rxcb *rxcb;
 	struct sk_buff *skb;
@@ -167,8 +163,8 @@ static int __ath10k_htt_rx_ring_fill_n(s
 				 skb->data);
 
 		/* Clear rx_desc attention word before posting to Rx ring */
-		rx_desc = HTT_RX_BUF_TO_RX_DESC(hw, skb->data);
-		ath10k_htt_rx_desc_get_attention(hw, rx_desc)->flags = __cpu_to_le32(0);
+		rx_desc = (struct htt_rx_desc *)skb->data;
+		rx_desc->attention.flags = __cpu_to_le32(0);
 
 		paddr = dma_map_single(htt->ar->dev, skb->data,
 				       skb->len + skb_tailroom(skb),
@@ -351,14 +347,9 @@ static int ath10k_htt_rx_amsdu_pop(struc
 				   struct sk_buff_head *amsdu)
 {
 	struct ath10k *ar = htt->ar;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	int msdu_len, msdu_chaining = 0;
 	struct sk_buff *msdu;
 	struct htt_rx_desc *rx_desc;
-	struct rx_attention *rx_desc_attention;
-	struct rx_frag_info_common *rx_desc_frag_info_common;
-	struct rx_msdu_start_common *rx_desc_msdu_start_common;
-	struct rx_msdu_end_common *rx_desc_msdu_end_common;
 
 	lockdep_assert_held(&htt->rx_ring.lock);
 
@@ -373,18 +364,13 @@ static int ath10k_htt_rx_amsdu_pop(struc
 
 		__skb_queue_tail(amsdu, msdu);
 
-		rx_desc = HTT_RX_BUF_TO_RX_DESC(hw, msdu->data);
-		rx_desc_attention = ath10k_htt_rx_desc_get_attention(hw, rx_desc);
-		rx_desc_msdu_start_common = ath10k_htt_rx_desc_get_msdu_start(hw,
-									      rx_desc);
-		rx_desc_msdu_end_common = ath10k_htt_rx_desc_get_msdu_end(hw, rx_desc);
-		rx_desc_frag_info_common = ath10k_htt_rx_desc_get_frag_info(hw, rx_desc);
+		rx_desc = (struct htt_rx_desc *)msdu->data;
 
 		/* FIXME: we must report msdu payload since this is what caller
 		 * expects now
 		 */
-		skb_put(msdu, hw->rx_desc_ops->rx_desc_msdu_payload_offset);
-		skb_pull(msdu, hw->rx_desc_ops->rx_desc_msdu_payload_offset);
+		skb_put(msdu, offsetof(struct htt_rx_desc, msdu_payload));
+		skb_pull(msdu, offsetof(struct htt_rx_desc, msdu_payload));
 
 		/*
 		 * Sanity check - confirm the HW is finished filling in the
@@ -394,24 +380,24 @@ static int ath10k_htt_rx_amsdu_pop(struc
 		 * To prevent the case that we handle a stale Rx descriptor,
 		 * just assert for now until we have a way to recover.
 		 */
-		if (!(__le32_to_cpu(rx_desc_attention->flags)
+		if (!(__le32_to_cpu(rx_desc->attention.flags)
 				& RX_ATTENTION_FLAGS_MSDU_DONE)) {
 			__skb_queue_purge(amsdu);
 			return -EIO;
 		}
 
-		msdu_len_invalid = !!(__le32_to_cpu(rx_desc_attention->flags)
+		msdu_len_invalid = !!(__le32_to_cpu(rx_desc->attention.flags)
 					& (RX_ATTENTION_FLAGS_MPDU_LENGTH_ERR |
 					   RX_ATTENTION_FLAGS_MSDU_LENGTH_ERR));
-		msdu_len = MS(__le32_to_cpu(rx_desc_msdu_start_common->info0),
+		msdu_len = MS(__le32_to_cpu(rx_desc->msdu_start.common.info0),
 			      RX_MSDU_START_INFO0_MSDU_LENGTH);
-		msdu_chained = rx_desc_frag_info_common->ring2_more_count;
+		msdu_chained = rx_desc->frag_info.ring2_more_count;
 
 		if (msdu_len_invalid)
 			msdu_len = 0;
 
 		skb_trim(msdu, 0);
-		skb_put(msdu, min(msdu_len, ath10k_htt_rx_msdu_size(hw)));
+		skb_put(msdu, min(msdu_len, HTT_RX_MSDU_SIZE));
 		msdu_len -= msdu->len;
 
 		/* Note: Chained buffers do not contain rx descriptor */
@@ -429,12 +415,11 @@ static int ath10k_htt_rx_amsdu_pop(struc
 			msdu_chaining = 1;
 		}
 
-		last_msdu = __le32_to_cpu(rx_desc_msdu_end_common->info0) &
+		last_msdu = __le32_to_cpu(rx_desc->msdu_end.common.info0) &
 				RX_MSDU_END_INFO0_LAST_MSDU;
 
-		/* FIXME: why are we skipping the first part of the rx_desc? */
-		trace_ath10k_htt_rx_desc(ar, (void *)rx_desc + sizeof(u32),
-					 hw->rx_desc_ops->rx_desc_size - sizeof(u32));
+		trace_ath10k_htt_rx_desc(ar, &rx_desc->attention,
+					 sizeof(*rx_desc) - sizeof(u32));
 
 		if (last_msdu)
 			break;
@@ -499,7 +484,6 @@ static int ath10k_htt_rx_handle_amsdu_mo
 					     struct htt_rx_in_ord_msdu_desc **msdu_desc)
 {
 	struct ath10k *ar = htt->ar;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	u32 paddr;
 	struct sk_buff *frag_buf;
 	struct sk_buff *prev_frag_buf;
@@ -508,12 +492,12 @@ static int ath10k_htt_rx_handle_amsdu_mo
 	struct htt_rx_desc *rxd;
 	int amsdu_len = __le16_to_cpu(ind_desc->msdu_len);
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw, msdu->data);
-	trace_ath10k_htt_rx_desc(ar, rxd, hw->rx_desc_ops->rx_desc_size);
+	rxd = (void *)msdu->data;
+	trace_ath10k_htt_rx_desc(ar, rxd, sizeof(*rxd));
 
-	skb_put(msdu, hw->rx_desc_ops->rx_desc_size);
-	skb_pull(msdu, hw->rx_desc_ops->rx_desc_size);
-	skb_put(msdu, min(amsdu_len, ath10k_htt_rx_msdu_size(hw)));
+	skb_put(msdu, sizeof(struct htt_rx_desc));
+	skb_pull(msdu, sizeof(struct htt_rx_desc));
+	skb_put(msdu, min(amsdu_len, HTT_RX_MSDU_SIZE));
 	amsdu_len -= msdu->len;
 
 	last_frag = ind_desc->reserved;
@@ -576,7 +560,6 @@ ath10k_htt_rx_handle_amsdu_mon_64(struct
 				  struct htt_rx_in_ord_msdu_desc_ext **msdu_desc)
 {
 	struct ath10k *ar = htt->ar;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	u64 paddr;
 	struct sk_buff *frag_buf;
 	struct sk_buff *prev_frag_buf;
@@ -585,12 +568,12 @@ ath10k_htt_rx_handle_amsdu_mon_64(struct
 	struct htt_rx_desc *rxd;
 	int amsdu_len = __le16_to_cpu(ind_desc->msdu_len);
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw, msdu->data);
-	trace_ath10k_htt_rx_desc(ar, rxd, hw->rx_desc_ops->rx_desc_size);
+	rxd = (void *)msdu->data;
+	trace_ath10k_htt_rx_desc(ar, rxd, sizeof(*rxd));
 
-	skb_put(msdu, hw->rx_desc_ops->rx_desc_size);
-	skb_pull(msdu, hw->rx_desc_ops->rx_desc_size);
-	skb_put(msdu, min(amsdu_len, ath10k_htt_rx_msdu_size(hw)));
+	skb_put(msdu, sizeof(struct htt_rx_desc));
+	skb_pull(msdu, sizeof(struct htt_rx_desc));
+	skb_put(msdu, min(amsdu_len, HTT_RX_MSDU_SIZE));
 	amsdu_len -= msdu->len;
 
 	last_frag = ind_desc->reserved;
@@ -652,10 +635,8 @@ static int ath10k_htt_rx_pop_paddr32_lis
 					  struct sk_buff_head *list)
 {
 	struct ath10k *ar = htt->ar;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_in_ord_msdu_desc *msdu_desc = ev->msdu_descs32;
 	struct htt_rx_desc *rxd;
-	struct rx_attention *rxd_attention;
 	struct sk_buff *msdu;
 	int msdu_count, ret;
 	bool is_offload;
@@ -690,16 +671,15 @@ static int ath10k_htt_rx_pop_paddr32_lis
 		__skb_queue_tail(list, msdu);
 
 		if (!is_offload) {
-			rxd = HTT_RX_BUF_TO_RX_DESC(hw, msdu->data);
-			rxd_attention = ath10k_htt_rx_desc_get_attention(hw, rxd);
+			rxd = (void *)msdu->data;
 
-			trace_ath10k_htt_rx_desc(ar, rxd, hw->rx_desc_ops->rx_desc_size);
+			trace_ath10k_htt_rx_desc(ar, rxd, sizeof(*rxd));
 
-			skb_put(msdu, hw->rx_desc_ops->rx_desc_size);
-			skb_pull(msdu, hw->rx_desc_ops->rx_desc_size);
+			skb_put(msdu, sizeof(*rxd));
+			skb_pull(msdu, sizeof(*rxd));
 			skb_put(msdu, __le16_to_cpu(msdu_desc->msdu_len));
 
-			if (!(__le32_to_cpu(rxd_attention->flags) &
+			if (!(__le32_to_cpu(rxd->attention.flags) &
 			      RX_ATTENTION_FLAGS_MSDU_DONE)) {
 				ath10k_warn(htt->ar, "tried to pop an incomplete frame, oops!\n");
 				return -EIO;
@@ -717,10 +697,8 @@ static int ath10k_htt_rx_pop_paddr64_lis
 					  struct sk_buff_head *list)
 {
 	struct ath10k *ar = htt->ar;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_in_ord_msdu_desc_ext *msdu_desc = ev->msdu_descs64;
 	struct htt_rx_desc *rxd;
-	struct rx_attention *rxd_attention;
 	struct sk_buff *msdu;
 	int msdu_count, ret;
 	bool is_offload;
@@ -754,16 +732,15 @@ static int ath10k_htt_rx_pop_paddr64_lis
 		__skb_queue_tail(list, msdu);
 
 		if (!is_offload) {
-			rxd = HTT_RX_BUF_TO_RX_DESC(hw, msdu->data);
-			rxd_attention = ath10k_htt_rx_desc_get_attention(hw, rxd);
+			rxd = (void *)msdu->data;
 
-			trace_ath10k_htt_rx_desc(ar, rxd, hw->rx_desc_ops->rx_desc_size);
+			trace_ath10k_htt_rx_desc(ar, rxd, sizeof(*rxd));
 
-			skb_put(msdu, hw->rx_desc_ops->rx_desc_size);
-			skb_pull(msdu, hw->rx_desc_ops->rx_desc_size);
+			skb_put(msdu, sizeof(*rxd));
+			skb_pull(msdu, sizeof(*rxd));
 			skb_put(msdu, __le16_to_cpu(msdu_desc->msdu_len));
 
-			if (!(__le32_to_cpu(rxd_attention->flags) &
+			if (!(__le32_to_cpu(rxd->attention.flags) &
 			      RX_ATTENTION_FLAGS_MSDU_DONE)) {
 				ath10k_warn(htt->ar, "tried to pop an incomplete frame, oops!\n");
 				return -EIO;
@@ -973,32 +950,16 @@ static void ath10k_htt_rx_h_rates(struct
 				  struct ieee80211_rx_status *status,
 				  struct htt_rx_desc *rxd)
 {
-	struct ath10k_hw_params *hw = &ar->hw_params;
-	struct rx_attention *rxd_attention;
-	struct rx_mpdu_start *rxd_mpdu_start;
-	struct rx_mpdu_end *rxd_mpdu_end;
-	struct rx_msdu_start_common *rxd_msdu_start_common;
-	struct rx_msdu_end_common *rxd_msdu_end_common;
-	struct rx_ppdu_start *rxd_ppdu_start;
 	struct ieee80211_supported_band *sband;
 	u8 cck, rate, bw, sgi, mcs, nss;
-	u8 *rxd_msdu_payload;
 	u8 preamble = 0;
 	u8 group_id;
 	u32 info1, info2, info3;
 	u32 stbc, nsts_su;
 
-	rxd_attention = ath10k_htt_rx_desc_get_attention(hw, rxd);
-	rxd_mpdu_start = ath10k_htt_rx_desc_get_mpdu_start(hw, rxd);
-	rxd_mpdu_end = ath10k_htt_rx_desc_get_mpdu_end(hw, rxd);
-	rxd_msdu_start_common = ath10k_htt_rx_desc_get_msdu_start(hw, rxd);
-	rxd_msdu_end_common = ath10k_htt_rx_desc_get_msdu_end(hw, rxd);
-	rxd_ppdu_start = ath10k_htt_rx_desc_get_ppdu_start(hw, rxd);
-	rxd_msdu_payload = ath10k_htt_rx_desc_get_msdu_payload(hw, rxd);
-
-	info1 = __le32_to_cpu(rxd_ppdu_start->info1);
-	info2 = __le32_to_cpu(rxd_ppdu_start->info2);
-	info3 = __le32_to_cpu(rxd_ppdu_start->info3);
+	info1 = __le32_to_cpu(rxd->ppdu_start.info1);
+	info2 = __le32_to_cpu(rxd->ppdu_start.info2);
+	info3 = __le32_to_cpu(rxd->ppdu_start.info3);
 
 	preamble = MS(info1, RX_PPDU_START_INFO1_PREAMBLE_TYPE);
 
@@ -1067,24 +1028,24 @@ static void ath10k_htt_rx_h_rates(struct
 		if (mcs > 0x09) {
 			ath10k_warn(ar, "invalid MCS received %u\n", mcs);
 			ath10k_warn(ar, "rxd %08x mpdu start %08x %08x msdu start %08x %08x ppdu start %08x %08x %08x %08x %08x\n",
-				    __le32_to_cpu(rxd_attention->flags),
-				    __le32_to_cpu(rxd_mpdu_start->info0),
-				    __le32_to_cpu(rxd_mpdu_start->info1),
-				    __le32_to_cpu(rxd_msdu_start_common->info0),
-				    __le32_to_cpu(rxd_msdu_start_common->info1),
-				    rxd_ppdu_start->info0,
-				    __le32_to_cpu(rxd_ppdu_start->info1),
-				    __le32_to_cpu(rxd_ppdu_start->info2),
-				    __le32_to_cpu(rxd_ppdu_start->info3),
-				    __le32_to_cpu(rxd_ppdu_start->info4));
+				    __le32_to_cpu(rxd->attention.flags),
+				    __le32_to_cpu(rxd->mpdu_start.info0),
+				    __le32_to_cpu(rxd->mpdu_start.info1),
+				    __le32_to_cpu(rxd->msdu_start.common.info0),
+				    __le32_to_cpu(rxd->msdu_start.common.info1),
+				    rxd->ppdu_start.info0,
+				    __le32_to_cpu(rxd->ppdu_start.info1),
+				    __le32_to_cpu(rxd->ppdu_start.info2),
+				    __le32_to_cpu(rxd->ppdu_start.info3),
+				    __le32_to_cpu(rxd->ppdu_start.info4));
 
 			ath10k_warn(ar, "msdu end %08x mpdu end %08x\n",
-				    __le32_to_cpu(rxd_msdu_end_common->info0),
-				    __le32_to_cpu(rxd_mpdu_end->info0));
+				    __le32_to_cpu(rxd->msdu_end.common.info0),
+				    __le32_to_cpu(rxd->mpdu_end.info0));
 
 			ath10k_dbg_dump(ar, ATH10K_DBG_HTT_DUMP, NULL,
 					"rx desc msdu payload: ",
-					rxd_msdu_payload, 50);
+					rxd->msdu_payload, 50);
 		}
 
 		status->rate_idx = mcs;
@@ -1104,10 +1065,6 @@ static void ath10k_htt_rx_h_rates(struct
 static struct ieee80211_channel *
 ath10k_htt_rx_h_peer_channel(struct ath10k *ar, struct htt_rx_desc *rxd)
 {
-	struct ath10k_hw_params *hw = &ar->hw_params;
-	struct rx_attention *rxd_attention;
-	struct rx_msdu_end_common *rxd_msdu_end_common;
-	struct rx_mpdu_start *rxd_mpdu_start;
 	struct ath10k_peer *peer;
 	struct ath10k_vif *arvif;
 	struct cfg80211_chan_def def;
@@ -1118,19 +1075,15 @@ ath10k_htt_rx_h_peer_channel(struct ath1
 	if (!rxd)
 		return NULL;
 
-	rxd_attention = ath10k_htt_rx_desc_get_attention(hw, rxd);
-	rxd_msdu_end_common = ath10k_htt_rx_desc_get_msdu_end(hw, rxd);
-	rxd_mpdu_start = ath10k_htt_rx_desc_get_mpdu_start(hw, rxd);
-
-	if (rxd_attention->flags &
+	if (rxd->attention.flags &
 	    __cpu_to_le32(RX_ATTENTION_FLAGS_PEER_IDX_INVALID))
 		return NULL;
 
-	if (!(rxd_msdu_end_common->info0 &
+	if (!(rxd->msdu_end.common.info0 &
 	      __cpu_to_le32(RX_MSDU_END_INFO0_FIRST_MSDU)))
 		return NULL;
 
-	peer_id = MS(__le32_to_cpu(rxd_mpdu_start->info0),
+	peer_id = MS(__le32_to_cpu(rxd->mpdu_start.info0),
 		     RX_MPDU_START_INFO0_PEER_IDX);
 
 	peer = ath10k_peer_find_by_id(ar, peer_id);
@@ -1220,16 +1173,14 @@ static void ath10k_htt_rx_h_signal(struc
 				   struct ieee80211_rx_status *status,
 				   struct htt_rx_desc *rxd)
 {
-	struct ath10k_hw_params *hw = &ar->hw_params;
-	struct rx_ppdu_start *rxd_ppdu_start = ath10k_htt_rx_desc_get_ppdu_start(hw, rxd);
 	int i;
 
 	for (i = 0; i < IEEE80211_MAX_CHAINS ; i++) {
 		status->chains &= ~BIT(i);
 
-		if (rxd_ppdu_start->rssi_chains[i].pri20_mhz != 0x80) {
+		if (rxd->ppdu_start.rssi_chains[i].pri20_mhz != 0x80) {
 			status->chain_signal[i] = ATH10K_DEFAULT_NOISE_FLOOR +
-				rxd_ppdu_start->rssi_chains[i].pri20_mhz;
+				rxd->ppdu_start.rssi_chains[i].pri20_mhz;
 
 			status->chains |= BIT(i);
 		}
@@ -1237,7 +1188,7 @@ static void ath10k_htt_rx_h_signal(struc
 
 	/* FIXME: Get real NF */
 	status->signal = ATH10K_DEFAULT_NOISE_FLOOR +
-			 rxd_ppdu_start->rssi_comb;
+			 rxd->ppdu_start.rssi_comb;
 	status->flag &= ~RX_FLAG_NO_SIGNAL_VAL;
 }
 
@@ -1245,18 +1196,13 @@ static void ath10k_htt_rx_h_mactime(stru
 				    struct ieee80211_rx_status *status,
 				    struct htt_rx_desc *rxd)
 {
-	struct ath10k_hw_params *hw = &ar->hw_params;
-	struct rx_ppdu_end_common *rxd_ppdu_end_common;
-
-	rxd_ppdu_end_common = ath10k_htt_rx_desc_get_ppdu_end(hw, rxd);
-
 	/* FIXME: TSF is known only at the end of PPDU, in the last MPDU. This
 	 * means all prior MSDUs in a PPDU are reported to mac80211 without the
 	 * TSF. Is it worth holding frames until end of PPDU is known?
 	 *
 	 * FIXME: Can we get/compute 64bit TSF?
 	 */
-	status->mactime = __le32_to_cpu(rxd_ppdu_end_common->tsf_timestamp);
+	status->mactime = __le32_to_cpu(rxd->ppdu_end.common.tsf_timestamp);
 	status->flag |= RX_FLAG_MACTIME_END;
 }
 
@@ -1266,9 +1212,7 @@ static void ath10k_htt_rx_h_ppdu(struct
 				 u32 vdev_id)
 {
 	struct sk_buff *first;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_desc *rxd;
-	struct rx_attention *rxd_attention;
 	bool is_first_ppdu;
 	bool is_last_ppdu;
 
@@ -1276,14 +1220,11 @@ static void ath10k_htt_rx_h_ppdu(struct
 		return;
 
 	first = skb_peek(amsdu);
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)first->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_attention = ath10k_htt_rx_desc_get_attention(hw, rxd);
+	rxd = (void *)first->data - sizeof(*rxd);
 
-	is_first_ppdu = !!(rxd_attention->flags &
+	is_first_ppdu = !!(rxd->attention.flags &
 			   __cpu_to_le32(RX_ATTENTION_FLAGS_FIRST_MPDU));
-	is_last_ppdu = !!(rxd_attention->flags &
+	is_last_ppdu = !!(rxd->attention.flags &
 			  __cpu_to_le32(RX_ATTENTION_FLAGS_LAST_MPDU));
 
 	if (is_first_ppdu) {
@@ -1422,9 +1363,7 @@ static void ath10k_htt_rx_h_undecap_raw(
 					const u8 first_hdr[64])
 {
 	struct ieee80211_hdr *hdr;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_desc *rxd;
-	struct rx_msdu_end_common *rxd_msdu_end_common;
 	size_t hdr_len;
 	size_t crypto_len;
 	bool is_first;
@@ -1433,13 +1372,10 @@ static void ath10k_htt_rx_h_undecap_raw(
 	int bytes_aligned = ar->hw_params.decap_align_bytes;
 	u8 *qos;
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)msdu->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_msdu_end_common = ath10k_htt_rx_desc_get_msdu_end(hw, rxd);
-	is_first = !!(rxd_msdu_end_common->info0 &
+	rxd = (void *)msdu->data - sizeof(*rxd);
+	is_first = !!(rxd->msdu_end.common.info0 &
 		      __cpu_to_le32(RX_MSDU_END_INFO0_FIRST_MSDU));
-	is_last = !!(rxd_msdu_end_common->info0 &
+	is_last = !!(rxd->msdu_end.common.info0 &
 		     __cpu_to_le32(RX_MSDU_END_INFO0_LAST_MSDU));
 
 	/* Delivered decapped frame:
@@ -1457,7 +1393,7 @@ static void ath10k_htt_rx_h_undecap_raw(
 	 * error packets. If limit exceeds, hw sends all remaining MSDUs as
 	 * a single last MSDU with this msdu limit error set.
 	 */
-	msdu_limit_err = ath10k_htt_rx_desc_msdu_limit_error(hw, rxd);
+	msdu_limit_err = ath10k_rx_desc_msdu_limit_error(&ar->hw_params, rxd);
 
 	/* If MSDU limit error happens, then don't warn on, the partial raw MSDU
 	 * without first MSDU is expected in that case, and handled later here.
@@ -1549,7 +1485,6 @@ static void ath10k_htt_rx_h_undecap_nwif
 					  const u8 first_hdr[64],
 					  enum htt_rx_mpdu_encrypt_type enctype)
 {
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct ieee80211_hdr *hdr;
 	struct htt_rx_desc *rxd;
 	size_t hdr_len;
@@ -1570,10 +1505,9 @@ static void ath10k_htt_rx_h_undecap_nwif
 	 */
 
 	/* pull decapped header and copy SA & DA */
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw, (void *)msdu->data -
-				    hw->rx_desc_ops->rx_desc_size);
+	rxd = (void *)msdu->data - sizeof(*rxd);
 
-	l3_pad_bytes = ath10k_htt_rx_desc_get_l3_pad_bytes(&ar->hw_params, rxd);
+	l3_pad_bytes = ath10k_rx_desc_get_l3_pad_bytes(&ar->hw_params, rxd);
 	skb_put(msdu, l3_pad_bytes);
 
 	hdr = (struct ieee80211_hdr *)(msdu->data + l3_pad_bytes);
@@ -1609,25 +1543,18 @@ static void *ath10k_htt_rx_h_find_rfc104
 					  enum htt_rx_mpdu_encrypt_type enctype)
 {
 	struct ieee80211_hdr *hdr;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_desc *rxd;
-	struct rx_msdu_end_common *rxd_msdu_end_common;
-	u8 *rxd_rx_hdr_status;
 	size_t hdr_len, crypto_len;
 	void *rfc1042;
 	bool is_first, is_last, is_amsdu;
 	int bytes_aligned = ar->hw_params.decap_align_bytes;
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)msdu->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_msdu_end_common = ath10k_htt_rx_desc_get_msdu_end(hw, rxd);
-	rxd_rx_hdr_status = ath10k_htt_rx_desc_get_rx_hdr_status(hw, rxd);
-	hdr = (void *)rxd_rx_hdr_status;
+	rxd = (void *)msdu->data - sizeof(*rxd);
+	hdr = (void *)rxd->rx_hdr_status;
 
-	is_first = !!(rxd_msdu_end_common->info0 &
+	is_first = !!(rxd->msdu_end.common.info0 &
 		      __cpu_to_le32(RX_MSDU_END_INFO0_FIRST_MSDU));
-	is_last = !!(rxd_msdu_end_common->info0 &
+	is_last = !!(rxd->msdu_end.common.info0 &
 		     __cpu_to_le32(RX_MSDU_END_INFO0_LAST_MSDU));
 	is_amsdu = !(is_first && is_last);
 
@@ -1653,7 +1580,6 @@ static void ath10k_htt_rx_h_undecap_eth(
 					const u8 first_hdr[64],
 					enum htt_rx_mpdu_encrypt_type enctype)
 {
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct ieee80211_hdr *hdr;
 	struct ethhdr *eth;
 	size_t hdr_len;
@@ -1673,10 +1599,8 @@ static void ath10k_htt_rx_h_undecap_eth(
 	if (WARN_ON_ONCE(!rfc1042))
 		return;
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)msdu->data - hw->rx_desc_ops->rx_desc_size);
-
-	l3_pad_bytes = ath10k_htt_rx_desc_get_l3_pad_bytes(&ar->hw_params, rxd);
+	rxd = (void *)msdu->data - sizeof(*rxd);
+	l3_pad_bytes = ath10k_rx_desc_get_l3_pad_bytes(&ar->hw_params, rxd);
 	skb_put(msdu, l3_pad_bytes);
 	skb_pull(msdu, l3_pad_bytes);
 
@@ -1717,7 +1641,6 @@ static void ath10k_htt_rx_h_undecap_snap
 					 const u8 first_hdr[64],
 					 enum htt_rx_mpdu_encrypt_type enctype)
 {
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct ieee80211_hdr *hdr;
 	size_t hdr_len;
 	int l3_pad_bytes;
@@ -1730,10 +1653,8 @@ static void ath10k_htt_rx_h_undecap_snap
 	 * [payload]
 	 */
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)msdu->data - hw->rx_desc_ops->rx_desc_size);
-
-	l3_pad_bytes = ath10k_htt_rx_desc_get_l3_pad_bytes(&ar->hw_params, rxd);
+	rxd = (void *)msdu->data - sizeof(*rxd);
+	l3_pad_bytes = ath10k_rx_desc_get_l3_pad_bytes(&ar->hw_params, rxd);
 
 	skb_put(msdu, l3_pad_bytes);
 	skb_pull(msdu, sizeof(struct amsdu_subframe_hdr) + l3_pad_bytes);
@@ -1758,9 +1679,7 @@ static void ath10k_htt_rx_h_undecap(stru
 				    enum htt_rx_mpdu_encrypt_type enctype,
 				    bool is_decrypted)
 {
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_desc *rxd;
-	struct rx_msdu_start_common *rxd_msdu_start_common;
 	enum rx_msdu_decap_format decap;
 
 	/* First msdu's decapped header:
@@ -1774,11 +1693,8 @@ static void ath10k_htt_rx_h_undecap(stru
 	 * [rfc1042/llc]
 	 */
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)msdu->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_msdu_start_common = ath10k_htt_rx_desc_get_msdu_start(hw, rxd);
-	decap = MS(__le32_to_cpu(rxd_msdu_start_common->info1),
+	rxd = (void *)msdu->data - sizeof(*rxd);
+	decap = MS(__le32_to_cpu(rxd->msdu_start.common.info1),
 		   RX_MSDU_START_INFO1_DECAP_FORMAT);
 
 	switch (decap) {
@@ -1800,23 +1716,17 @@ static void ath10k_htt_rx_h_undecap(stru
 	}
 }
 
-static int ath10k_htt_rx_get_csum_state(struct ath10k_hw_params *hw, struct sk_buff *skb)
+static int ath10k_htt_rx_get_csum_state(struct sk_buff *skb)
 {
 	struct htt_rx_desc *rxd;
-	struct rx_attention *rxd_attention;
-	struct rx_msdu_start_common *rxd_msdu_start_common;
 	u32 flags, info;
 	bool is_ip4, is_ip6;
 	bool is_tcp, is_udp;
 	bool ip_csum_ok, tcpudp_csum_ok;
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)skb->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_attention = ath10k_htt_rx_desc_get_attention(hw, rxd);
-	rxd_msdu_start_common = ath10k_htt_rx_desc_get_msdu_start(hw, rxd);
-	flags = __le32_to_cpu(rxd_attention->flags);
-	info = __le32_to_cpu(rxd_msdu_start_common->info1);
+	rxd = (void *)skb->data - sizeof(*rxd);
+	flags = __le32_to_cpu(rxd->attention.flags);
+	info = __le32_to_cpu(rxd->msdu_start.common.info1);
 
 	is_ip4 = !!(info & RX_MSDU_START_INFO1_IPV4_PROTO);
 	is_ip6 = !!(info & RX_MSDU_START_INFO1_IPV6_PROTO);
@@ -1837,10 +1747,9 @@ static int ath10k_htt_rx_get_csum_state(
 	return CHECKSUM_UNNECESSARY;
 }
 
-static void ath10k_htt_rx_h_csum_offload(struct ath10k_hw_params *hw,
-					 struct sk_buff *msdu)
+static void ath10k_htt_rx_h_csum_offload(struct sk_buff *msdu)
 {
-	msdu->ip_summed = ath10k_htt_rx_get_csum_state(hw, msdu);
+	msdu->ip_summed = ath10k_htt_rx_get_csum_state(msdu);
 }
 
 static u64 ath10k_htt_rx_h_get_pn(struct ath10k *ar, struct sk_buff *skb,
@@ -1932,11 +1841,7 @@ static void ath10k_htt_rx_h_mpdu(struct
 	struct sk_buff *first;
 	struct sk_buff *last;
 	struct sk_buff *msdu, *temp;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_desc *rxd;
-	struct rx_attention *rxd_attention;
-	struct rx_mpdu_start *rxd_mpdu_start;
-
 	struct ieee80211_hdr *hdr;
 	enum htt_rx_mpdu_encrypt_type enctype;
 	u8 first_hdr[64];
@@ -1954,22 +1859,18 @@ static void ath10k_htt_rx_h_mpdu(struct
 		return;
 
 	first = skb_peek(amsdu);
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)first->data - hw->rx_desc_ops->rx_desc_size);
+	rxd = (void *)first->data - sizeof(*rxd);
 
-	rxd_attention = ath10k_htt_rx_desc_get_attention(hw, rxd);
-	rxd_mpdu_start = ath10k_htt_rx_desc_get_mpdu_start(hw, rxd);
-
-	is_mgmt = !!(rxd_attention->flags &
+	is_mgmt = !!(rxd->attention.flags &
 		     __cpu_to_le32(RX_ATTENTION_FLAGS_MGMT_TYPE));
 
-	enctype = MS(__le32_to_cpu(rxd_mpdu_start->info0),
+	enctype = MS(__le32_to_cpu(rxd->mpdu_start.info0),
 		     RX_MPDU_START_INFO0_ENCRYPT_TYPE);
 
 	/* First MSDU's Rx descriptor in an A-MSDU contains full 802.11
 	 * decapped header. It'll be used for undecapping of each MSDU.
 	 */
-	hdr = (void *)ath10k_htt_rx_desc_get_rx_hdr_status(hw, rxd);
+	hdr = (void *)rxd->rx_hdr_status;
 	memcpy(first_hdr, hdr, RX_HTT_HDR_STATUS_LEN);
 
 	if (rx_hdr)
@@ -1987,11 +1888,8 @@ static void ath10k_htt_rx_h_mpdu(struct
 
 	/* Some attention flags are valid only in the last MSDU. */
 	last = skb_peek_tail(amsdu);
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)last->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_attention = ath10k_htt_rx_desc_get_attention(hw, rxd);
-	attention = __le32_to_cpu(rxd_attention->flags);
+	rxd = (void *)last->data - sizeof(*rxd);
+	attention = __le32_to_cpu(rxd->attention.flags);
 
 	has_fcs_err = !!(attention & RX_ATTENTION_FLAGS_FCS_ERR);
 	has_crypto_err = !!(attention & RX_ATTENTION_FLAGS_DECRYPT_ERR);
@@ -2079,7 +1977,7 @@ static void ath10k_htt_rx_h_mpdu(struct
 			continue;
 		}
 
-		ath10k_htt_rx_h_csum_offload(&ar->hw_params, msdu);
+		ath10k_htt_rx_h_csum_offload(msdu);
 
 		if (frag && !fill_crypt_header &&
 		    enctype == HTT_RX_MPDU_ENCRYPT_TKIP_WPA)
@@ -2191,19 +2089,12 @@ static void ath10k_htt_rx_h_unchain(stru
 				    unsigned long *unchain_cnt)
 {
 	struct sk_buff *first;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_desc *rxd;
-	struct rx_msdu_start_common *rxd_msdu_start_common;
-	struct rx_frag_info_common *rxd_frag_info;
 	enum rx_msdu_decap_format decap;
 
 	first = skb_peek(amsdu);
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)first->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_msdu_start_common = ath10k_htt_rx_desc_get_msdu_start(hw, rxd);
-	rxd_frag_info = ath10k_htt_rx_desc_get_frag_info(hw, rxd);
-	decap = MS(__le32_to_cpu(rxd_msdu_start_common->info1),
+	rxd = (void *)first->data - sizeof(*rxd);
+	decap = MS(__le32_to_cpu(rxd->msdu_start.common.info1),
 		   RX_MSDU_START_INFO1_DECAP_FORMAT);
 
 	/* FIXME: Current unchaining logic can only handle simple case of raw
@@ -2212,7 +2103,7 @@ static void ath10k_htt_rx_h_unchain(stru
 	 * try re-constructing such frames - it'll be pretty much garbage.
 	 */
 	if (decap != RX_MSDU_DECAP_RAW ||
-	    skb_queue_len(amsdu) != 1 + rxd_frag_info->ring2_more_count) {
+	    skb_queue_len(amsdu) != 1 + rxd->frag_info.ring2_more_count) {
 		*drop_cnt += skb_queue_len(amsdu);
 		__skb_queue_purge(amsdu);
 		return;
@@ -2227,10 +2118,7 @@ static bool ath10k_htt_rx_validate_amsdu
 	u8 *subframe_hdr;
 	struct sk_buff *first;
 	bool is_first, is_last;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct htt_rx_desc *rxd;
-	struct rx_msdu_end_common *rxd_msdu_end_common;
-	struct rx_mpdu_start *rxd_mpdu_start;
 	struct ieee80211_hdr *hdr;
 	size_t hdr_len, crypto_len;
 	enum htt_rx_mpdu_encrypt_type enctype;
@@ -2238,16 +2126,12 @@ static bool ath10k_htt_rx_validate_amsdu
 
 	first = skb_peek(amsdu);
 
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)first->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_msdu_end_common = ath10k_htt_rx_desc_get_msdu_end(hw, rxd);
-	rxd_mpdu_start = ath10k_htt_rx_desc_get_mpdu_start(hw, rxd);
-	hdr = (void *)ath10k_htt_rx_desc_get_rx_hdr_status(hw, rxd);
+	rxd = (void *)first->data - sizeof(*rxd);
+	hdr = (void *)rxd->rx_hdr_status;
 
-	is_first = !!(rxd_msdu_end_common->info0 &
+	is_first = !!(rxd->msdu_end.common.info0 &
 		      __cpu_to_le32(RX_MSDU_END_INFO0_FIRST_MSDU));
-	is_last = !!(rxd_msdu_end_common->info0 &
+	is_last = !!(rxd->msdu_end.common.info0 &
 		     __cpu_to_le32(RX_MSDU_END_INFO0_LAST_MSDU));
 
 	/* Return in case of non-aggregated msdu */
@@ -2258,7 +2142,7 @@ static bool ath10k_htt_rx_validate_amsdu
 	if (!is_first)
 		return false;
 
-	enctype = MS(__le32_to_cpu(rxd_mpdu_start->info0),
+	enctype = MS(__le32_to_cpu(rxd->mpdu_start.info0),
 		     RX_MPDU_START_INFO0_ENCRYPT_TYPE);
 
 	hdr_len = ieee80211_hdrlen(hdr->frame_control);
@@ -3150,13 +3034,11 @@ static void ath10k_htt_rx_delba(struct a
 	spin_unlock_bh(&ar->data_lock);
 }
 
-static int ath10k_htt_rx_extract_amsdu(struct ath10k_hw_params *hw,
-				       struct sk_buff_head *list,
+static int ath10k_htt_rx_extract_amsdu(struct sk_buff_head *list,
 				       struct sk_buff_head *amsdu)
 {
 	struct sk_buff *msdu;
 	struct htt_rx_desc *rxd;
-	struct rx_msdu_end_common *rxd_msdu_end_common;
 
 	if (skb_queue_empty(list))
 		return -ENOBUFS;
@@ -3167,22 +3049,15 @@ static int ath10k_htt_rx_extract_amsdu(s
 	while ((msdu = __skb_dequeue(list))) {
 		__skb_queue_tail(amsdu, msdu);
 
-		rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-					    (void *)msdu->data -
-					    hw->rx_desc_ops->rx_desc_size);
-
-		rxd_msdu_end_common = ath10k_htt_rx_desc_get_msdu_end(hw, rxd);
-		if (rxd_msdu_end_common->info0 &
+		rxd = (void *)msdu->data - sizeof(*rxd);
+		if (rxd->msdu_end.common.info0 &
 		    __cpu_to_le32(RX_MSDU_END_INFO0_LAST_MSDU))
 			break;
 	}
 
 	msdu = skb_peek_tail(amsdu);
-	rxd = HTT_RX_BUF_TO_RX_DESC(hw,
-				    (void *)msdu->data - hw->rx_desc_ops->rx_desc_size);
-
-	rxd_msdu_end_common = ath10k_htt_rx_desc_get_msdu_end(hw, rxd);
-	if (!(rxd_msdu_end_common->info0 &
+	rxd = (void *)msdu->data - sizeof(*rxd);
+	if (!(rxd->msdu_end.common.info0 &
 	      __cpu_to_le32(RX_MSDU_END_INFO0_LAST_MSDU))) {
 		skb_queue_splice_init(amsdu, list);
 		return -EAGAIN;
@@ -3325,7 +3200,7 @@ static int ath10k_htt_rx_in_ord_ind(stru
 
 	while (!skb_queue_empty(&list)) {
 		__skb_queue_head_init(&amsdu);
-		ret = ath10k_htt_rx_extract_amsdu(&ar->hw_params, &list, &amsdu);
+		ret = ath10k_htt_rx_extract_amsdu(&list, &amsdu);
 		switch (ret) {
 		case 0:
 			/* Note: The in-order indication may report interleaved
--- a/drivers/net/wireless/ath/ath10k/htt_tx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_tx.c
@@ -796,26 +796,47 @@ static int ath10k_htt_send_frag_desc_ban
 	return 0;
 }
 
-static void ath10k_htt_fill_rx_desc_offset_32(struct ath10k_hw_params *hw, void *rx_ring)
+static void ath10k_htt_fill_rx_desc_offset_32(void *rx_ring)
 {
 	struct htt_rx_ring_setup_ring32 *ring =
 			(struct htt_rx_ring_setup_ring32 *)rx_ring;
 
-	ath10k_htt_rx_desc_get_offsets(hw, &ring->offsets);
+#define desc_offset(x) (offsetof(struct htt_rx_desc, x) / 4)
+	ring->mac80211_hdr_offset = __cpu_to_le16(desc_offset(rx_hdr_status));
+	ring->msdu_payload_offset = __cpu_to_le16(desc_offset(msdu_payload));
+	ring->ppdu_start_offset = __cpu_to_le16(desc_offset(ppdu_start));
+	ring->ppdu_end_offset = __cpu_to_le16(desc_offset(ppdu_end));
+	ring->mpdu_start_offset = __cpu_to_le16(desc_offset(mpdu_start));
+	ring->mpdu_end_offset = __cpu_to_le16(desc_offset(mpdu_end));
+	ring->msdu_start_offset = __cpu_to_le16(desc_offset(msdu_start));
+	ring->msdu_end_offset = __cpu_to_le16(desc_offset(msdu_end));
+	ring->rx_attention_offset = __cpu_to_le16(desc_offset(attention));
+	ring->frag_info_offset = __cpu_to_le16(desc_offset(frag_info));
+#undef desc_offset
 }
 
-static void ath10k_htt_fill_rx_desc_offset_64(struct ath10k_hw_params *hw, void *rx_ring)
+static void ath10k_htt_fill_rx_desc_offset_64(void *rx_ring)
 {
 	struct htt_rx_ring_setup_ring64 *ring =
 			(struct htt_rx_ring_setup_ring64 *)rx_ring;
 
-	ath10k_htt_rx_desc_get_offsets(hw, &ring->offsets);
+#define desc_offset(x) (offsetof(struct htt_rx_desc, x) / 4)
+	ring->mac80211_hdr_offset = __cpu_to_le16(desc_offset(rx_hdr_status));
+	ring->msdu_payload_offset = __cpu_to_le16(desc_offset(msdu_payload));
+	ring->ppdu_start_offset = __cpu_to_le16(desc_offset(ppdu_start));
+	ring->ppdu_end_offset = __cpu_to_le16(desc_offset(ppdu_end));
+	ring->mpdu_start_offset = __cpu_to_le16(desc_offset(mpdu_start));
+	ring->mpdu_end_offset = __cpu_to_le16(desc_offset(mpdu_end));
+	ring->msdu_start_offset = __cpu_to_le16(desc_offset(msdu_start));
+	ring->msdu_end_offset = __cpu_to_le16(desc_offset(msdu_end));
+	ring->rx_attention_offset = __cpu_to_le16(desc_offset(attention));
+	ring->frag_info_offset = __cpu_to_le16(desc_offset(frag_info));
+#undef desc_offset
 }
 
 static int ath10k_htt_send_rx_ring_cfg_32(struct ath10k_htt *htt)
 {
 	struct ath10k *ar = htt->ar;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct sk_buff *skb;
 	struct htt_cmd *cmd;
 	struct htt_rx_ring_setup_ring32 *ring;
@@ -875,7 +896,7 @@ static int ath10k_htt_send_rx_ring_cfg_3
 	ring->flags = __cpu_to_le16(flags);
 	ring->fw_idx_init_val = __cpu_to_le16(fw_idx);
 
-	ath10k_htt_fill_rx_desc_offset_32(hw, ring);
+	ath10k_htt_fill_rx_desc_offset_32(ring);
 	ret = ath10k_htc_send(&htt->ar->htc, htt->eid, skb);
 	if (ret) {
 		dev_kfree_skb_any(skb);
@@ -888,7 +909,6 @@ static int ath10k_htt_send_rx_ring_cfg_3
 static int ath10k_htt_send_rx_ring_cfg_64(struct ath10k_htt *htt)
 {
 	struct ath10k *ar = htt->ar;
-	struct ath10k_hw_params *hw = &ar->hw_params;
 	struct sk_buff *skb;
 	struct htt_cmd *cmd;
 	struct htt_rx_ring_setup_ring64 *ring;
@@ -945,7 +965,7 @@ static int ath10k_htt_send_rx_ring_cfg_6
 	ring->flags = __cpu_to_le16(flags);
 	ring->fw_idx_init_val = __cpu_to_le16(fw_idx);
 
-	ath10k_htt_fill_rx_desc_offset_64(hw, ring);
+	ath10k_htt_fill_rx_desc_offset_64(ring);
 	ret = ath10k_htc_send(&htt->ar->htc, htt->eid, skb);
 	if (ret) {
 		dev_kfree_skb_any(skb);
--- a/drivers/net/wireless/ath/ath10k/hw.c
+++ b/drivers/net/wireless/ath/ath10k/hw.c
@@ -11,7 +11,6 @@
 #include "hif.h"
 #include "wmi-ops.h"
 #include "bmi.h"
-#include "rx_desc.h"
 
 const struct ath10k_hw_regs qca988x_regs = {
 	.rtc_soc_base_address		= 0x00004000,
@@ -1135,7 +1134,21 @@ const struct ath10k_hw_ops qca988x_ops =
 	.is_rssi_enable = ath10k_htt_tx_rssi_enable,
 };
 
+static int ath10k_qca99x0_rx_desc_get_l3_pad_bytes(struct htt_rx_desc *rxd)
+{
+	return MS(__le32_to_cpu(rxd->msdu_end.qca99x0.info1),
+		  RX_MSDU_END_INFO1_L3_HDR_PAD);
+}
+
+static bool ath10k_qca99x0_rx_desc_msdu_limit_error(struct htt_rx_desc *rxd)
+{
+	return !!(rxd->msdu_end.common.info0 &
+		  __cpu_to_le32(RX_MSDU_END_INFO0_MSDU_LIMIT_ERR));
+}
+
 const struct ath10k_hw_ops qca99x0_ops = {
+	.rx_desc_get_l3_pad_bytes = ath10k_qca99x0_rx_desc_get_l3_pad_bytes,
+	.rx_desc_get_msdu_limit_error = ath10k_qca99x0_rx_desc_msdu_limit_error,
 	.is_rssi_enable = ath10k_htt_tx_rssi_enable,
 };
 
--- a/drivers/net/wireless/ath/ath10k/hw.h
+++ b/drivers/net/wireless/ath/ath10k/hw.h
@@ -510,8 +510,6 @@ struct ath10k_hw_clk_params {
 	u32 outdiv;
 };
 
-struct htt_rx_desc_ops;
-
 struct ath10k_hw_params {
 	u32 id;
 	u16 dev_id;
@@ -565,9 +563,6 @@ struct ath10k_hw_params {
 	 */
 	bool sw_decrypt_mcast_mgmt;
 
-	/* Rx descriptor abstraction */
-	const struct ath10k_htt_rx_desc_ops *rx_desc_ops;
-
 	const struct ath10k_hw_ops *hw_ops;
 
 	/* Number of bytes used for alignment in rx_hdr_status of rx desc. */
@@ -642,14 +637,16 @@ struct ath10k_hw_params {
 	bool delay_unmap_buffer;
 };
 
+struct htt_rx_desc;
 struct htt_resp;
 struct htt_data_tx_completion_ext;
-struct htt_rx_ring_rx_desc_offsets;
 
 /* Defines needed for Rx descriptor abstraction */
 struct ath10k_hw_ops {
+	int (*rx_desc_get_l3_pad_bytes)(struct htt_rx_desc *rxd);
 	void (*set_coverage_class)(struct ath10k *ar, s16 value);
 	int (*enable_pll_clk)(struct ath10k *ar);
+	bool (*rx_desc_get_msdu_limit_error)(struct htt_rx_desc *rxd);
 	int (*tx_data_rssi_pad_bytes)(struct htt_resp *htt);
 	int (*is_rssi_enable)(struct htt_resp *resp);
 };
@@ -663,6 +660,24 @@ extern const struct ath10k_hw_ops wcn399
 extern const struct ath10k_hw_clk_params qca6174_clk[];
 
 static inline int
+ath10k_rx_desc_get_l3_pad_bytes(struct ath10k_hw_params *hw,
+				struct htt_rx_desc *rxd)
+{
+	if (hw->hw_ops->rx_desc_get_l3_pad_bytes)
+		return hw->hw_ops->rx_desc_get_l3_pad_bytes(rxd);
+	return 0;
+}
+
+static inline bool
+ath10k_rx_desc_msdu_limit_error(struct ath10k_hw_params *hw,
+				struct htt_rx_desc *rxd)
+{
+	if (hw->hw_ops->rx_desc_get_msdu_limit_error)
+		return hw->hw_ops->rx_desc_get_msdu_limit_error(rxd);
+	return false;
+}
+
+static inline int
 ath10k_tx_data_rssi_get_pad_bytes(struct ath10k_hw_params *hw,
 				  struct htt_resp *htt)
 {
--- a/drivers/net/wireless/ath/ath10k/rx_desc.h
+++ b/drivers/net/wireless/ath/ath10k/rx_desc.h
@@ -196,31 +196,17 @@ struct rx_attention {
  *		descriptor.
  */
 
-struct rx_frag_info_common {
+struct rx_frag_info {
 	u8 ring0_more_count;
 	u8 ring1_more_count;
 	u8 ring2_more_count;
 	u8 ring3_more_count;
-} __packed;
-
-struct rx_frag_info_wcn3990 {
 	u8 ring4_more_count;
 	u8 ring5_more_count;
 	u8 ring6_more_count;
 	u8 ring7_more_count;
 } __packed;
 
-struct rx_frag_info {
-	struct rx_frag_info_common common;
-	union {
-		struct rx_frag_info_wcn3990 wcn3990;
-	} __packed;
-} __packed;
-
-struct rx_frag_info_v1 {
-	struct rx_frag_info_common common;
-} __packed;
-
 /*
  * ring0_more_count
  *		Indicates the number of more buffers associated with RX DMA
@@ -488,14 +474,8 @@ struct rx_msdu_start_wcn3990 {
 struct rx_msdu_start {
 	struct rx_msdu_start_common common;
 	union {
-		struct rx_msdu_start_wcn3990 wcn3990;
-	} __packed;
-} __packed;
-
-struct rx_msdu_start_v1 {
-	struct rx_msdu_start_common common;
-	union {
 		struct rx_msdu_start_qca99x0 qca99x0;
+		struct rx_msdu_start_wcn3990 wcn3990;
 	} __packed;
 } __packed;
 
@@ -632,14 +612,8 @@ struct rx_msdu_end_wcn3990 {
 struct rx_msdu_end {
 	struct rx_msdu_end_common common;
 	union {
-		struct rx_msdu_end_wcn3990 wcn3990;
-	} __packed;
-} __packed;
-
-struct rx_msdu_end_v1 {
-	struct rx_msdu_end_common common;
-	union {
 		struct rx_msdu_end_qca99x0 qca99x0;
+		struct rx_msdu_end_wcn3990 wcn3990;
 	} __packed;
 } __packed;
 
@@ -1162,17 +1136,11 @@ struct rx_ppdu_end_wcn3990 {
 struct rx_ppdu_end {
 	struct rx_ppdu_end_common common;
 	union {
-		struct rx_ppdu_end_wcn3990 wcn3990;
-	} __packed;
-} __packed;
-
-struct rx_ppdu_end_v1 {
-	struct rx_ppdu_end_common common;
-	union {
 		struct rx_ppdu_end_qca988x qca988x;
 		struct rx_ppdu_end_qca6174 qca6174;
 		struct rx_ppdu_end_qca99x0 qca99x0;
 		struct rx_ppdu_end_qca9984 qca9984;
+		struct rx_ppdu_end_wcn3990 wcn3990;
 	} __packed;
 } __packed;
 
