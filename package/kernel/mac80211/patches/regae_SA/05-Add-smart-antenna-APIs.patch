From ad72a23769d87a77ae93e9e5061e76a7afb78b70 Mon Sep 17 00:00:00 2001
From: oliverwen <oliverwen@google.com>
Date: Fri, 24 Jun 2016 19:17:07 -0700
Subject: [PATCH] CHROMIUM: Add smart antenna APIs

This patch defines APIs used for smart antenna algorithm.
Has a full implementation os wmi ops used for smart antenna
configuration. There is a new module param which is used to
enable smart antenna logic on host and firmware.

Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@codeaurora.org>

TEST=build/boot. Load ath10k_core with modparam set enable_smart_antenna=1,
bring up AP mode using hostapd and connect a station to this AP.
Device was able to connect to the internet and load multiple websites.
This testing is done on AP148.

BUG=chrome-os-partner:51964
CQ-DEPEND=CL:341524

Signed-off-by: oliverwen <oliverwen@google.com>
(cherry picked from commit 9a81c88af18aeb7c732184408e569275273d14df)
(cherry picked from wireless-3.18)

Change-Id: I4fefdde10c8e431767d2f17f09bad07e5f1383cc
Reviewed-on: https://chromium-review.googlesource.com/341525
Commit-Ready: Yixiang Li <yixiang@google.com>
Tested-by: Oliver Wen <oliverwen@chromium.org>
Reviewed-by: Yixiang Li <yixiang@google.com>
---
 drivers/net/wireless/ath/ath10k/core.c    |  34 ++-
 drivers/net/wireless/ath/ath10k/core.h    |  44 +++
 drivers/net/wireless/ath/ath10k/debug.h   |   1 +
 drivers/net/wireless/ath/ath10k/htt_rx.c  |   9 +
 drivers/net/wireless/ath/ath10k/hw.h      |  15 ++
 drivers/net/wireless/ath/ath10k/mac.c     |  65 ++++-
 .../net/wireless-4.2/ath/ath10k/smart_ant.h   |  93 +++++++
 drivers/net/wireless/ath/ath10k/wmi-ops.h |  86 +++++-
 drivers/net/wireless/ath/ath10k/wmi.c     | 254 +++++++++++++++++-
 drivers/net/wireless/ath/ath10k/wmi.h     |  72 +++++
 10 files changed, 668 insertions(+), 5 deletions(-)
 create mode 100644 drivers/net/wireless/ath/ath10k/smart_ant.h

diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index 3d08ae69da0..4ac1e633157 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -36,6 +36,9 @@ static unsigned int ath10k_cryptmode_par
 static bool uart_print;
 static bool skip_otp;
 static bool fw_diag_log;
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+bool ath10k_enable_smart_antenna = false;
+#endif
 
 /* frame mode values are mapped as per enum ath10k_hw_txrx_mode */
 unsigned int ath10k_frame_mode = ATH10K_HW_TXRX_NATIVE_WIFI;
@@ -51,6 +54,10 @@ module_param(skip_otp, bool, 0644);
 module_param(fw_diag_log, bool, 0644);
 module_param_named(frame_mode, ath10k_frame_mode, uint, 0644);
 module_param_named(coredump_mask, ath10k_coredump_mask, ulong, 0444);
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+module_param_named(enable_smart_antenna, ath10k_enable_smart_antenna,
+		   bool, 0644);
+#endif
 
 MODULE_PARM_DESC(debug_mask, "Debugging mask");
 MODULE_PARM_DESC(uart_print, "Uart target debugging");
@@ -60,6 +67,9 @@ MODULE_PARM_DESC(frame_mode,
 		 "Datapath frame mode (0: raw, 1: native wifi (default), 2: ethernet)");
 MODULE_PARM_DESC(coredump_mask, "Bitfield of what to include in firmware crash file");
 MODULE_PARM_DESC(fw_diag_log, "Diag based fw log debugging");
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+MODULE_PARM_DESC(enable_smart_antenna, "Enable smart antenna supprot in fw");
+#endif
 
 static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 	{
@@ -2776,12 +2786,29 @@ static int ath10k_core_init_firmware_features(struct ath10k *ar)
 	case ATH10K_FW_WMI_OP_VERSION_10_2:
 	case ATH10K_FW_WMI_OP_VERSION_10_2_4:
 		if (ath10k_peer_stats_enabled(ar)) {
-			max_num_peers = TARGET_10X_TX_STATS_NUM_PEERS;
-			ar->max_num_stations = TARGET_10X_TX_STATS_NUM_STATIONS;
+			max_num_peers =
+					  TARGET_10X_TX_STATS_NUM_PEERS;
+			ar->max_num_stations =
+				       TARGET_10X_TX_STATS_NUM_STATIONS;
 		} else {
 			max_num_peers = TARGET_10X_NUM_PEERS;
 			ar->max_num_stations = TARGET_10X_NUM_STATIONS;
 		}
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+		if (ath10k_enable_smart_antenna) {
+			if (ath10k_peer_stats_enabled(ar)) {
+				max_num_peers =
+				       TARGET_10_2_SMART_ANT_TX_STATS_NUM_PEERS;
+				ar->max_num_stations =
+				    TARGET_10_2_SMART_ANT_TX_STATS_NUM_STATIONS;
+			} else {
+				max_num_peers =
+						TARGET_10_2_SMART_ANT_NUM_PEERS;
+				ar->max_num_stations =
+					     TARGET_10_2_SMART_ANT_NUM_STATIONS;
+			}
+		}
+#endif
 		ar->max_num_vdevs = TARGET_10X_NUM_VDEVS;
 		ar->htt.max_num_pending_tx = TARGET_10X_NUM_MSDU_DESC;
 		ar->fw_stats_req_mask = WMI_STAT_PEER;
@@ -3739,6 +3766,9 @@ struct ath10k *ath10k_core_create(size_t priv_size, struct device *dev,
 	init_completion(&ar->bss_survey_done);
 	init_completion(&ar->peer_delete_done);
 	init_completion(&ar->peer_stats_info_complete);
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	init_completion(&ar->ratecode_evt);
+#endif
 
 	INIT_DELAYED_WORK(&ar->scan.timeout, ath10k_scan_timeout_work);
 
diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h
index 2f6ccf241ea..11d6e821169 100644
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -1008,6 +1008,19 @@ struct ath10k_bus_params {
 	bool hl_msdu_ids;
 };
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+#define ATH10K_RATECODE_LIST_TIMEOUT	100 /* msecs */
+
+struct ath10k_peer_ratecode_list {
+	u8 mac_addr[ETH_ALEN];
+	u8 rtcode_legacy[WMI_CCK_OFDM_RATES_MAX];
+	u8 rtcode_20[WMI_MCS_RATES_MAX];
+	u8 rtcode_40[WMI_MCS_RATES_MAX];
+	u8 rtcode_80[WMI_MCS_RATES_MAX];
+	u8 rt_count[WMI_RATE_COUNT_MAX];
+};
+#endif
+
 struct ath10k {
 	struct ath_common ath_common;
 	struct ieee80211_hw *hw;
@@ -1313,6 +1326,14 @@ struct ath10k {
 	const char *led_default_trigger;
 #endif
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	struct completion ratecode_evt;
+	/* Temporary place to store peer's rate code reported in RATECODE_LIST
+	 * wmi event after successful assoc_complete command
+	 */
+	struct ath10k_peer_ratecode_list ratecode_list;
+#endif
+
 	/* must be last */
 	u8 drv_priv[] __aligned(sizeof(void *));
 };
@@ -1329,6 +1350,29 @@ static inline bool ath10k_peer_stats_enabled(struct ath10k *ar)
 extern unsigned int ath10k_frame_mode;
 extern unsigned long ath10k_coredump_mask;
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+extern bool ath10k_enable_smart_antenna;
+
+static inline bool ath10k_smart_ant_enabled(struct ath10k *ar)
+{
+	if (!test_bit(WMI_SERVICE_SMART_ANTENNA_SW_SUPPORT, ar->wmi.svc_map))
+		return false;
+
+	if (!test_bit(WMI_SERVICE_SMART_ANTENNA_HW_SUPPORT, ar->wmi.svc_map))
+		return false;
+
+	if (!ath10k_enable_smart_antenna)
+		return false;
+
+	return true;
+}
+#else
+static inline bool ath10k_smart_ant_enabled(struct ath10k *ar)
+{
+	return false;
+}
+#endif
+
 void ath10k_core_napi_sync_disable(struct ath10k *ar);
 void ath10k_core_napi_enable(struct ath10k *ar);
 struct ath10k *ath10k_core_create(size_t priv_size, struct device *dev,
diff --git a/drivers/net/wireless/ath/ath10k/debug.h b/drivers/net/wireless/ath/ath10k/debug.h
index 057e07ac81d..6cc4cb031e0 100644
--- a/drivers/net/wireless/ath/ath10k/debug.h
+++ b/drivers/net/wireless/ath/ath10k/debug.h
@@ -44,8 +44,9 @@ enum ath10k_pktlog_filter {
 	ATH10K_PKTLOG_RCFIND     = 0x000000004,
 	ATH10K_PKTLOG_RCUPDATE   = 0x000000008,
 	ATH10K_PKTLOG_DBG_PRINT  = 0x000000010,
+	ATH10K_PKTLOG_SMART_ANT	 = 0x000000020,
 	ATH10K_PKTLOG_PEER_STATS = 0x000000040,
-	ATH10K_PKTLOG_ANY        = 0x00000005f,
+	ATH10K_PKTLOG_ANY        = 0x00000007f,
 };
 
 enum ath10k_dbg_aggr_mode {
diff --git a/drivers/net/wireless/ath/ath10k/htt_rx.c b/drivers/net/wireless/ath/ath10k/htt_rx.c
index 360a510c8db..212c30a0e05 100644
--- a/drivers/net/wireless/ath/ath10k/htt_rx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
@@ -12,6 +12,9 @@
 #include "debug.h"
 #include "trace.h"
 #include "mac.h"
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+#include "smart_ant.h"
+#endif
 
 #include <linux/log2.h>
 #include <linux/bitfield.h>
@@ -420,6 +423,9 @@ static int ath10k_htt_rx_amsdu_pop(struct ath10k_htt *htt,
 
 		trace_ath10k_htt_rx_desc(ar, &rx_desc->attention,
 					 sizeof(*rx_desc) - sizeof(u32));
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+		ath10k_smart_ant_proc_rx_feedback(ar, rx_desc);
+#endif
 
 		if (last_msdu)
 			break;
@@ -4096,6 +4102,9 @@ void ath10k_htt_t2h_msg_handler(struct ath10k *ar, struct sk_buff *skb)
 		if (ath10k_peer_stats_enabled(ar))
 			ath10k_fetch_10_2_tx_stats(ar,
 						   resp->pktlog_msg.payload);
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+		ath10k_smart_ant_proc_tx_feedback(ar, resp->pktlog_msg.payload);
+#endif
 		break;
 	}
 	case HTT_T2H_MSG_TYPE_RX_FLUSH: {
diff --git a/drivers/net/wireless/ath/ath10k/hw.h b/drivers/net/wireless/ath/ath10k/hw.h
index 8a5d4fcb531..5a724568f69 100644
--- a/drivers/net/wireless/ath/ath10k/hw.h
+++ b/drivers/net/wireless/ath/ath10k/hw.h
@@ -737,10 +737,18 @@ enum ath10k_hw_4addr_pad {
 #define TARGET_10X_AST_SKID_LIMIT		128
 #define TARGET_10X_NUM_STATIONS			128
 #define TARGET_10X_TX_STATS_NUM_STATIONS	118
+#define TARGET_10_2_SMART_ANT_NUM_STATIONS      115
+#define TARGET_10_2_SMART_ANT_TX_STATS_NUM_STATIONS    100
 #define TARGET_10X_NUM_PEERS			((TARGET_10X_NUM_STATIONS) + \
 						 (TARGET_10X_NUM_VDEVS))
 #define TARGET_10X_TX_STATS_NUM_PEERS		((TARGET_10X_TX_STATS_NUM_STATIONS) + \
 						 (TARGET_10X_NUM_VDEVS))
+#define TARGET_10_2_SMART_ANT_NUM_PEERS \
+		(TARGET_10_2_SMART_ANT_NUM_STATIONS + \
+		 TARGET_10X_NUM_VDEVS)
+#define TARGET_10_2_SMART_ANT_TX_STATS_NUM_PEERS \
+		(TARGET_10_2_SMART_ANT_TX_STATS_NUM_STATIONS + \
+		 TARGET_10X_NUM_VDEVS)
 #define TARGET_10X_NUM_OFFLOAD_PEERS		0
 #define TARGET_10X_NUM_OFFLOAD_REORDER_BUFS	0
 #define TARGET_10X_NUM_PEER_KEYS		2
@@ -749,6 +757,12 @@ enum ath10k_hw_4addr_pad {
 						    (TARGET_10X_NUM_PEERS) * 2)
 #define TARGET_10X_TX_STATS_NUM_TIDS		min((TARGET_10X_NUM_TIDS_MAX), \
 						    (TARGET_10X_TX_STATS_NUM_PEERS) * 2)
+#define TARGET_10_2_SMART_ANT_NUM_TIDS \
+		min((TARGET_10X_NUM_TIDS_MAX), \
+			(TARGET_10_2_SMART_ANT_NUM_PEERS) * 2)
+#define TARGET_10_2_SMART_ANT_TX_STATS_NUM_TIDS \
+		min((TARGET_10X_NUM_TIDS_MAX), \
+			(TARGET_10_2_SMART_ANT_TX_STATS_NUM_PEERS) * 2)
 #define TARGET_10X_TX_CHAIN_MASK		(BIT(0) | BIT(1) | BIT(2))
 #define TARGET_10X_RX_CHAIN_MASK		(BIT(0) | BIT(1) | BIT(2))
 #define TARGET_10X_RX_TIMEOUT_LO_PRI		100
@@ -769,6 +783,7 @@ enum ath10k_hw_4addr_pad {
 
 /* 10.2 parameters */
 #define TARGET_10_2_DMA_BURST_SIZE		0
+#define TARGET_10_2_SMART_ANT_ENABLE		1
 
 /* Target specific defines for WMI-TLV firmware */
 #define TARGET_TLV_NUM_VDEVS			4
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index 7e000b7082a..7b5e0875ac6 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -25,6 +25,9 @@
 #include "wmi-ops.h"
 #include "wow.h"
 #include "leds.h"
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+#include "smart_ant.h"
+#endif
 
 /*********/
 /* Rates */
@@ -5876,6 +5879,23 @@ static int ath10k_add_interface(struct ieee80211_hw *hw,
 				    arvif->vdev_id, ret);
 	}
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	ret = ath10k_smart_ant_enable(ar, arvif);
+	if (ret) {
+		ath10k_warn(ar, "failed to enable smart antenna algorithm %d\n",
+			    ret);
+		goto err_peer_delete;
+	}
+
+	ret = ath10k_smart_ant_set_default(ar, arvif);
+	if (ret) {
+		ath10k_warn(ar, "failed to set default smart antenna configuration %d\n",
+			    ret);
+		ath10k_smart_ant_disable(ar, arvif);
+		goto err_peer_delete;
+	}
+#endif
+
 	if (vif->type == NL80211_IFTYPE_MONITOR) {
 		ar->monitor_arvif = arvif;
 		ret = ath10k_monitor_recalc(ar);
@@ -5947,6 +5967,10 @@ static void ath10k_remove_interface(struct ieee80211_hw *hw,
 
 	mutex_lock(&ar->conf_mutex);
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	ath10k_smart_ant_disable(ar, arvif);
+#endif
+
 	ret = ath10k_spectral_vif_stop(arvif);
 	if (ret)
 		ath10k_warn(ar, "failed to stop spectral for vdev %i: %d\n",
@@ -7703,10 +7727,45 @@ static int ath10k_sta_state(struct ieee80211_hw *hw,
 		ath10k_dbg(ar, ATH10K_DBG_STA, "mac sta %pM associated\n",
 			   sta->addr);
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+		reinit_completion(&ar->ratecode_evt);
+#endif
+
 		ret = ath10k_station_assoc(ar, vif, sta, false);
-		if (ret)
+		if (ret) {
 			ath10k_warn(ar, "failed to associate station %pM for vdev %i: %i\n",
 				    sta->addr, arvif->vdev_id, ret);
+			goto exit;
+		}
+
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+		/* wait for completion to get rate code list event from fw
+		 * after assoc_complete wmi command. This ratecode list info
+		 * can be used with smart antenna logic. As of now do this
+		 * only for AP mode because this is the only mode tested with
+		 * smart antenna APIs.
+		 */
+		if (vif->type == NL80211_IFTYPE_AP &&
+		    ath10k_smart_ant_enabled(ar)) {
+			int timeout;
+
+			timeout = wait_for_completion_timeout(
+			&ar->ratecode_evt,
+			msecs_to_jiffies(ATH10K_RATECODE_LIST_TIMEOUT));
+			if (timeout == 0) {
+				ath10k_warn(ar, "timeout on rate code list event %pM\n",
+					    sta->addr);
+				ret = -ETIMEDOUT;
+				goto exit;
+			}
+
+			if (ath10k_smart_ant_sta_connect(ar, arvif, sta)) {
+				ath10k_warn(ar,
+					    "Smart antenna station connect failed, disabling smart antenna for %pM\n",
+					    sta->addr);
+			}
+		}
+#endif
 	} else if (old_state == IEEE80211_STA_ASSOC &&
 		   new_state == IEEE80211_STA_AUTHORIZED &&
 		   sta->tdls) {
@@ -7739,6 +7798,10 @@ static int ath10k_sta_state(struct ieee80211_hw *hw,
 		ath10k_dbg(ar, ATH10K_DBG_STA, "mac sta %pM disassociated\n",
 			   sta->addr);
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+		ath10k_smart_ant_sta_disconnect(ar, sta);
+#endif
+
 		ret = ath10k_station_disassoc(ar, vif, sta);
 		if (ret)
 			ath10k_warn(ar, "failed to disassociate station: %pM vdev %i: %i\n",
diff --git a/drivers/net/wireless/ath/ath10k/smart_ant.h b/drivers/net/wireless/ath/ath10k/smart_ant.h
new file mode 100644
index 00000000000..78830deb455
--- /dev/null
+++ b/drivers/net/wireless/ath/ath10k/smart_ant.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* This API is to process rx feedback such as rssi, PER and antennas.
+ * Based on the stats a better antenna combination can be found for rx.
+ * Better rx antenna can be configured using ath10k_wmi_pdev_set_rx_ant().
+ */
+
+#ifndef _SMART_ANT_H_
+#define _SMART_ANT_H_
+
+static inline void
+ath10k_smart_ant_proc_rx_feedback(struct ath10k *ar,
+				  struct htt_rx_desc *rx_desc)
+{
+}
+
+/* This API is to process tx feedback information such as tx rate
+ * PER, rssi and antennas used for tx. Based on feedback stats a
+ * a better antenna combination can be chosen for tx.
+ * Better tx antenna can be configured using ath10k_wmi_peer_set_smart_tx_ant().
+ * When needed this API can also request for feedback on packets with particular
+ * antenna at a particular rate.  This is called packet training and the params
+ * needed for training can be configured using
+ * ath10k_wmi_peer_set_smart_ant_train_info().
+ */
+static inline void
+ath10k_smart_ant_proc_tx_feedback(struct ath10k *ar, u8 *data)
+{
+}
+
+/* In AP mode, this API notifies of disassociation of a station.
+ * Station specific information related to smart antenna should
+ * be reset in this API.
+ */
+static inline void
+ath10k_smart_ant_sta_disconnect(struct ath10k *ar, struct ieee80211_sta *sta)
+{
+}
+
+/* In AP mode, this API is to notify of association of a station. Station
+ * specific information used for smart antenna may be initialized in this
+ * API. Peer specific smart antenna configuration in fw may need to be
+ * don from this API using ath10k_wmi_peer_cfg_smart_ant().
+ */
+static inline int
+ath10k_smart_ant_sta_connect(struct ath10k *ar, struct ath10k_vif *arvif,
+			     struct ieee80211_sta *sta)
+{
+	return 0;
+}
+
+/* This API is to set initial tx/rx antennas */
+static inline int
+ath10k_smart_ant_set_default(struct ath10k *ar, struct ath10k_vif *arvif)
+{
+	return 0;
+}
+
+/* This API reverts the configurations done in ath10k_smart_ant_enable().
+ * ath10k_wmi_pdev_disable_smart_ant needs to be called to disable
+ * smart antenna logic in fw.
+ */
+static inline void
+ath10k_smart_ant_disable(struct ath10k *ar, struct ath10k_vif *arvif)
+{
+}
+
+/* This smart antenna API configures fw with initial smart antenna params
+ * such as mode of antenna control and tx/rx antennas.
+ * This API calls ath10k_wmi_pdev_enable_smart_ant() to configure initial
+ * parameters for fw to start smart antenna. This API may also need to
+ * enable tx feedback through packetlog.
+ */
+static inline int
+ath10k_smart_ant_enable(struct ath10k *ar, struct ath10k_vif *arvif)
+{
+	return 0;
+}
+#endif
diff --git a/drivers/net/wireless/ath/ath10k/wmi-ops.h b/drivers/net/wireless/ath/ath10k/wmi-ops.h
index c8d72697543..3ccfb84aa23 100644
--- a/drivers/net/wireless/ath/ath10k/wmi-ops.h
+++ b/drivers/net/wireless/ath/ath10k/wmi-ops.h
@@ -237,6 +237,19 @@ struct wmi_ops {
 	struct sk_buff *(*gen_pdev_disable_smart_ant)(struct ath10k *ar,
 						      u32 mode, u32 tx_ant,
 						      u32 rx_ant);
+	struct sk_buff *(*gen_peer_set_smart_tx_ant)(struct ath10k *ar,
+						     u32 vdev_id,
+						     const u8 *macaddr,
+						     const u32 *ant_rate_list,
+						     int n_ants);
+	struct sk_buff *(*gen_pdev_set_rx_ant)(struct ath10k *ar, u32 antenna);
+	struct sk_buff *(*gen_peer_cfg_smart_ant_fb)(
+				struct ath10k *ar,
+				const struct wmi_smart_ant_sta_cfg_arg *arg);
+	struct sk_buff *(*gen_peer_set_smart_ant_train_info)(
+				struct ath10k *ar,
+				u32 vdev_id, const u8 *mac_addr,
+				const struct wmi_peer_sant_set_train_arg *arg);
 #endif
 };
 
@@ -1750,6 +1763,77 @@ ath10k_wmi_pdev_disable_smart_ant(struct ath10k *ar, u32 mode,
 	return ath10k_wmi_cmd_send(ar, skb,
 				   ar->wmi.cmd->pdev_set_smart_ant_cmdid);
 }
-#endif
 
+static inline int
+ath10k_wmi_peer_set_smart_tx_ant(struct ath10k *ar, u32 vdev_id,
+				 const u8 *macaddr, const u32 *ant_rate_list,
+				 int n_ants)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_peer_set_smart_tx_ant)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_peer_set_smart_tx_ant(ar, vdev_id, macaddr,
+						     ant_rate_list, n_ants);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb,
+				   ar->wmi.cmd->peer_set_smart_tx_ant_cmdid);
+}
+
+static inline int
+ath10k_wmi_pdev_set_rx_ant(struct ath10k *ar, u32 antenna)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_pdev_set_rx_ant)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_pdev_set_rx_ant(ar, antenna);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb,
+				   ar->wmi.cmd->pdev_set_rx_ant_cmdid);
+}
+
+static inline int
+ath10k_wmi_peer_cfg_smart_ant(struct ath10k *ar,
+			      const struct wmi_smart_ant_sta_cfg_arg *arg)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_peer_cfg_smart_ant_fb)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_peer_cfg_smart_ant_fb(ar, arg);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb,
+				   ar->wmi.cmd->peer_smart_ant_fb_config_cmdid);
+}
+
+static inline int
+ath10k_wmi_peer_set_smart_ant_train_info(
+			struct ath10k *ar,
+			u32 vdev_id, const u8 *macaddr,
+			const struct wmi_peer_sant_set_train_arg *arg)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_peer_set_smart_ant_train_info)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_peer_set_smart_ant_train_info(ar, vdev_id,
+							     macaddr, arg);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb,
+			ar->wmi.cmd->peer_set_smart_ant_train_info_cmdid);
+}
+#endif
 #endif
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index 1a180e72b3f..aacdc0ab569 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -193,6 +193,10 @@ static struct wmi_cmd_map wmi_cmd_map = {
 	.radar_found_cmdid = WMI_CMD_UNSUPPORTED,
 #ifdef CPTCFG_ATH10K_SMART_ANTENNA
 	.pdev_set_smart_ant_cmdid = WMI_CMD_UNSUPPORTED,
+	.pdev_set_rx_ant_cmdid = WMI_CMD_UNSUPPORTED,
+	.peer_set_smart_tx_ant_cmdid = WMI_CMD_UNSUPPORTED,
+	.peer_smart_ant_fb_config_cmdid = WMI_CMD_UNSUPPORTED,
+	.peer_set_smart_ant_train_info_cmdid = WMI_CMD_UNSUPPORTED,
 #endif
 };
 
@@ -365,6 +369,10 @@ static struct wmi_cmd_map wmi_10x_cmd_map = {
 	.radar_found_cmdid = WMI_CMD_UNSUPPORTED,
 #ifdef CPTCFG_ATH10K_SMART_ANTENNA
 	.pdev_set_smart_ant_cmdid = WMI_CMD_UNSUPPORTED,
+	.pdev_set_rx_ant_cmdid = WMI_CMD_UNSUPPORTED,
+	.peer_set_smart_tx_ant_cmdid = WMI_CMD_UNSUPPORTED,
+	.peer_smart_ant_fb_config_cmdid = WMI_CMD_UNSUPPORTED,
+	.peer_set_smart_ant_train_info_cmdid = WMI_CMD_UNSUPPORTED,
 #endif
 };
 
@@ -538,6 +546,13 @@ static struct wmi_cmd_map wmi_10_2_4_cmd_map = {
 	.set_bb_timing_cmdid = WMI_10_2_PDEV_SET_BB_TIMING_CONFIG_CMDID,
 #ifdef CPTCFG_ATH10K_SMART_ANTENNA
 	.pdev_set_smart_ant_cmdid = WMI_10_2_PDEV_SMART_ANT_ENABLE_CMDID,
+	.pdev_set_rx_ant_cmdid = WMI_10_2_PDEV_SMART_ANT_SET_RX_ANTENNA_CMDID,
+	.peer_set_smart_tx_ant_cmdid =
+				WMI_10_2_PEER_SMART_ANT_SET_TX_ANTENNA_CMDID,
+	.peer_smart_ant_fb_config_cmdid =
+			WMI_10_2_PEER_SMART_ANT_SET_NODE_CONFIG_OPS_CMDID,
+	.peer_set_smart_ant_train_info_cmdid =
+			WMI_10_2_PEER_SMART_ANT_SET_TRAIN_INFO_CMDID,
 #endif
 };
 
@@ -1521,6 +1536,13 @@ static struct wmi_cmd_map wmi_10_2_cmd_map = {
 	.radar_found_cmdid = WMI_CMD_UNSUPPORTED,
 #ifdef CPTCFG_ATH10K_SMART_ANTENNA
 	.pdev_set_smart_ant_cmdid = WMI_10_2_PDEV_SMART_ANT_ENABLE_CMDID,
+	.pdev_set_rx_ant_cmdid = WMI_10_2_PDEV_SMART_ANT_SET_RX_ANTENNA_CMDID,
+	.peer_set_smart_tx_ant_cmdid =
+				WMI_10_2_PEER_SMART_ANT_SET_TX_ANTENNA_CMDID,
+	.peer_smart_ant_fb_config_cmdid =
+			WMI_10_2_PEER_SMART_ANT_SET_NODE_CONFIG_OPS_CMDID,
+	.peer_set_smart_ant_train_info_cmdid =
+			WMI_10_2_PEER_SMART_ANT_SET_TRAIN_INFO_CMDID,
 #endif
 };
 
@@ -5858,6 +5880,59 @@ static inline void ath10k_wmi_queue_set_
 	}
 }
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+static int
+ath10k_wmi_event_ratecode_list(struct ath10k *ar, struct sk_buff *skb)
+{
+	struct wmi_peer_ratecode_list_event *ev =
+			(struct wmi_peer_ratecode_list_event *)skb->data;
+	int i;
+
+	if (!ath10k_smart_ant_enabled(ar))
+		return 0;
+
+	if (WARN_ON(skb->len < sizeof(*ev)))
+		return -EPROTO;
+
+	spin_lock_bh(&ar->data_lock);
+	memset(&ar->ratecode_list, 0, sizeof(ar->ratecode_list));
+	ether_addr_copy(ar->ratecode_list.mac_addr, ev->peer_macaddr.addr);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI,
+		   "wmi peer rate code list peer_addr %pM skb->len %zu ev-size %zu\n",
+		   ar->ratecode_list.mac_addr, skb->len, sizeof(*ev));
+
+	for (i = 0; i < WMI_RATE_COUNT_MAX; i++) {
+		ar->ratecode_list.rt_count[i] = ev->peer_rate_info.ratecount[i];
+		ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi ratecode list rate count[%d] %d\n",
+			   i, ar->ratecode_list.rt_count[i]);
+	}
+
+	/* Fill in legacy rate code */
+	memcpy(ar->ratecode_list.rtcode_legacy,
+	       ev->peer_rate_info.ratecode_legacy,
+	       WMI_CCK_OFDM_RATES_MAX);
+
+	/* Fill 20, 40 and 80 bw rate code */
+	memcpy(ar->ratecode_list.rtcode_20,
+	       ev->peer_rate_info.ratecode_20,
+	       WMI_MCS_RATES_MAX);
+
+	memcpy(ar->ratecode_list.rtcode_40,
+	       ev->peer_rate_info.ratecode_40,
+	       WMI_MCS_RATES_MAX);
+
+	memcpy(ar->ratecode_list.rtcode_80,
+	       ev->peer_rate_info.ratecode_80,
+	       WMI_MCS_RATES_MAX);
+
+	spin_unlock_bh(&ar->data_lock);
+
+	complete(&ar->ratecode_evt);
+	return 0;
+}
+#endif
+
 static void ath10k_wmi_op_rx(struct ath10k *ar, struct sk_buff *skb)
 {
 	struct wmi_cmd_hdr *cmd_hdr;
@@ -6243,9 +6318,13 @@ static void ath10k_wmi_10_2_op_rx(struct ath10k *ar, struct sk_buff *skb)
 	case WMI_10_2_PDEV_BSS_CHAN_INFO_EVENTID:
 		ath10k_wmi_event_pdev_bss_chan_info(ar, skb);
 		break;
+	case WMI_10_2_PEER_RATECODE_LIST_EVENTID:
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+		ath10k_wmi_event_ratecode_list(ar, skb);
+#endif
+		break;
 	case WMI_10_2_RTT_KEEPALIVE_EVENTID:
 	case WMI_10_2_GPIO_INPUT_EVENTID:
-	case WMI_10_2_PEER_RATECODE_LIST_EVENTID:
 	case WMI_10_2_GENERIC_BUFFER_EVENTID:
 	case WMI_10_2_MCAST_BUF_RELEASE_EVENTID:
 	case WMI_10_2_MCAST_LIST_AGEOUT_EVENTID:
@@ -6720,6 +6799,29 @@ static struct sk_buff *ath10k_wmi_10_2_op_gen_init(struct ath10k *ar)
 		config.num_peers = __cpu_to_le32(TARGET_10X_NUM_PEERS);
 		config.num_tids = __cpu_to_le32(TARGET_10X_NUM_TIDS);
 	}
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	if (ath10k_smart_ant_enabled(ar)) {
+		if (ath10k_peer_stats_enabled(ar)) {
+			config.num_peers =
+			__cpu_to_le32(min(
+				TARGET_10_2_SMART_ANT_TX_STATS_NUM_PEERS,
+				TARGET_10X_NUM_PEERS));
+			config.num_tids =
+			__cpu_to_le32(min(
+				TARGET_10_2_SMART_ANT_TX_STATS_NUM_TIDS,
+				TARGET_10X_NUM_TIDS));
+		} else {
+			config.num_peers =
+			__cpu_to_le32(min(
+				TARGET_10_2_SMART_ANT_NUM_PEERS,
+				TARGET_10X_NUM_PEERS));
+			config.num_tids =
+			__cpu_to_le32(min(
+				TARGET_10_2_SMART_ANT_NUM_TIDS,
+				TARGET_10X_NUM_TIDS));
+		}
+	}
+#endif
 
 	config.ast_skid_limit = __cpu_to_le32(TARGET_10X_AST_SKID_LIMIT);
 	config.tx_chain_mask = __cpu_to_le32(TARGET_10X_TX_CHAIN_MASK);
@@ -6781,6 +6883,13 @@ static struct sk_buff *ath10k_wmi_10_2_op_gen_init(struct ath10k *ar)
 
 	cmd->resource_config.feature_mask = __cpu_to_le32(features);
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	if (ath10k_smart_ant_enabled(ar)) {
+		cmd->resource_config.smart_ant_cap =
+			__cpu_to_le32(TARGET_10_2_SMART_ANT_ENABLE);
+	}
+#endif
+
 	memcpy(&cmd->resource_config.common, &config, sizeof(config));
 	ath10k_wmi_put_host_mem_chunks(ar, &cmd->mem_chunks);
 
@@ -9251,6 +9360,130 @@ ath10k_wmi_op_gen_pdev_disable_smart_ant(struct ath10k *ar, u32 mode,
 		   mode, rx_ant, tx_ant);
 	return skb;
 }
+
+/* Set tx antenna for a particular peer. Tx antennas is an array
+ * containing antennas for every rate fallback retry. After this
+ * antenna configuration all the frames to that particular peer
+ * are sent in the newly configured antenna combination.
+ */
+static struct sk_buff *
+ath10k_wmi_op_gen_peer_set_smart_tx_ant(struct ath10k *ar,
+					u32 vdev_id, const u8 *macaddr,
+					const u32 *ant_rate_list,
+					int n_ants)
+{
+	struct wmi_peer_set_smart_tx_ant_cmd *cmd;
+	struct sk_buff *skb;
+	int i;
+
+	if (n_ants > WMI_SMART_ANT_RATE_SERIES_MAX) {
+		ath10k_err(ar, "Invalid number of Tx antennas %d\n", n_ants);
+		return ERR_PTR(-EINVAL);
+	}
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_peer_set_smart_tx_ant_cmd *)skb->data;
+
+	cmd->vdev_id = __cpu_to_le32(vdev_id);
+	ether_addr_copy(cmd->peer_macaddr.addr, macaddr);
+	for (i = 0; i < n_ants; i++)
+		cmd->ant_series[i] = __cpu_to_le32(ant_rate_list[i]);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI,
+		   "wmi set tx antenna, vdev_id %d macaddr %pM\n",
+		   vdev_id, macaddr);
+	return skb;
+}
+
+/* Configures Rx antenna for a radio */
+static struct sk_buff *
+ath10k_wmi_op_gen_pdev_set_rx_ant(struct ath10k *ar, u32 antenna)
+{
+	struct wmi_pdev_set_rx_antenna_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_pdev_set_rx_antenna_cmd *)skb->data;
+	cmd->rx_antenna = __cpu_to_le32(antenna);
+	ath10k_dbg(ar, ATH10K_DBG_WMI,
+		   "wmi set rx antenna, antenna:%d\n", antenna);
+	return skb;
+}
+
+/* Configures smart antenna feedback options. This optimizes
+ * tx feedback by combining feedbacks for multiple packets in
+ * a single feedback indication. Algorithm uses this wmi
+ * interface once a particular station is connected.
+ */
+static struct sk_buff *
+ath10k_wmi_op_gen_peer_cfg_smart_ant(
+			struct ath10k *ar,
+			const struct wmi_smart_ant_sta_cfg_arg *arg)
+{
+	struct wmi_peer_cfg_smart_ant_cmd *cmd;
+	struct sk_buff *skb;
+	int i;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_peer_cfg_smart_ant_cmd *)skb->data;
+	cmd->cmd_id = __cpu_to_le32(WMI_SMART_ANT_TX_FEEDBACK_CONFIG_CMD);
+	cmd->vdev_id = __cpu_to_le32(arg->vdev_id);
+	ether_addr_copy(cmd->peer_macaddr.addr, arg->mac_addr.addr);
+	cmd->arg_cnt = __cpu_to_le32(arg->num_cfg);
+	for (i = 0; i < arg->num_cfg; i++)
+		cmd->args[i] = __cpu_to_le32(arg->cfg[i]);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI,
+		   "wmi peer set smart ant cfg, vdev_id %d macaddr %pM\n",
+		   arg->vdev_id, arg->mac_addr.addr);
+	return skb;
+}
+
+/* Configure parameters which will be used for training for a particular peer.
+ * Training parameters include rates, antennas and number of data packets
+ * used for training. Once training parameters are configured for a peer,
+ * any full sized MSDUs (~1.5K) will be used for training. Feedbacks received
+ * for training packets will be reported in packetlog tx events with training
+ * bit set.
+ */
+
+static struct sk_buff *
+ath10k_wmi_op_gen_set_smart_ant_train_info(
+			struct ath10k *ar, u32 vdev_id,
+			const u8 *mac_addr,
+			const struct wmi_peer_sant_set_train_arg *arg)
+{
+	struct wmi_peer_set_smart_ant_train_info_cmd *cmd;
+	struct sk_buff *skb;
+	int i;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_peer_set_smart_ant_train_info_cmd *)skb->data;
+	cmd->vdev_id = __cpu_to_le32(vdev_id);
+	ether_addr_copy(cmd->mac_addr.addr, mac_addr);
+	for (i = 0; i < WMI_SMART_ANT_RATE_SERIES_MAX; i++) {
+		cmd->train_rates[i] = __cpu_to_le32(arg->rates[i]);
+		cmd->train_ants[i] = __cpu_to_le32(arg->antennas[i]);
+	}
+	cmd->num_pkts = __cpu_to_le32(arg->num_pkts);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI,
+		   "wmi peer set smart ant train info vdev_id:%d pee_mac:%pM\n",
+		   vdev_id, mac_addr);
+	return skb;
+}
 #endif
 
 static const struct wmi_ops wmi_ops = {
@@ -9325,6 +9558,10 @@ static const struct wmi_ops wmi_ops = {
 	/* .gen_pdev_enable_adaptive_cca not implemented */
 	/* .gen_pdev_enable_smart_ant not implemented */
 	/* .gen_pdev_disable_smart_ant not implemented */
+	/* .gen_peer_set_smart_tx_ant not implemented */
+	/* .gen_pdev_set_rx_ant not implemented */
+	/* .gen_peer_cfg_smart_ant_fb not implemented */
+	/* .gen_peer_set_smart_ant_train_info not implemented */
 };
 
 static const struct wmi_ops wmi_10_1_ops = {
@@ -9399,6 +9636,10 @@ static const struct wmi_ops wmi_10_1_ops = {
 	/* .gen_pdev_enable_adaptive_cca not implemented */
 	/* .gen_pdev_enable_smart_ant not implemented */
 	/* .gen_pdev_disable_smart_ant not implemented */
+	/* .gen_peer_set_smart_tx_ant not implemented */
+	/* .gen_pdev_set_rx_ant not implemented */
+	/* .gen_peer_cfg_smart_ant_fb not implemented */
+	/* .gen_peer_set_smart_ant_train_info not implemented */
 };
 
 static const struct wmi_ops wmi_10_2_ops = {
@@ -9472,6 +9713,11 @@ static const struct wmi_ops wmi_10_2_ops = {
 #ifdef CPTCFG_ATH10K_SMART_ANTENNA
 	.gen_pdev_enable_smart_ant  = ath10k_wmi_op_gen_pdev_enable_smart_ant,
 	.gen_pdev_disable_smart_ant  = ath10k_wmi_op_gen_pdev_disable_smart_ant,
+	.gen_peer_set_smart_tx_ant = ath10k_wmi_op_gen_peer_set_smart_tx_ant,
+	.gen_pdev_set_rx_ant = ath10k_wmi_op_gen_pdev_set_rx_ant,
+	.gen_peer_cfg_smart_ant_fb = ath10k_wmi_op_gen_peer_cfg_smart_ant,
+	.gen_peer_set_smart_ant_train_info =
+				ath10k_wmi_op_gen_set_smart_ant_train_info,
 #endif
 };
 
@@ -9552,6 +9798,11 @@ static const struct wmi_ops wmi_10_2_4_ops = {
 #ifdef CPTCFG_ATH10K_SMART_ANTENNA
 	.gen_pdev_enable_smart_ant  = ath10k_wmi_op_gen_pdev_enable_smart_ant,
 	.gen_pdev_disable_smart_ant  = ath10k_wmi_op_gen_pdev_disable_smart_ant,
+	.gen_peer_set_smart_tx_ant = ath10k_wmi_op_gen_peer_set_smart_tx_ant,
+	.gen_pdev_set_rx_ant = ath10k_wmi_op_gen_pdev_set_rx_ant,
+	.gen_peer_cfg_smart_ant_fb = ath10k_wmi_op_gen_peer_cfg_smart_ant,
+	.gen_peer_set_smart_ant_train_info =
+				ath10k_wmi_op_gen_set_smart_ant_train_info,
 #endif
 };
 
diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h
index 329c659e1f1..ddfb859920d 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.h
+++ b/drivers/net/wireless/ath/ath10k/wmi.h
@@ -1045,7 +1045,13 @@ struct wmi_cmd_map {
 	u32 radar_found_cmdid;
 	u32 set_bb_timing_cmdid;
 	u32 per_peer_per_tid_config_cmdid;
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
 	u32 pdev_set_smart_ant_cmdid;
+	u32 pdev_set_rx_ant_cmdid;
+	u32 peer_set_smart_tx_ant_cmdid;
+	u32 peer_smart_ant_fb_config_cmdid;
+	u32 peer_set_smart_ant_train_info_cmdid;
+#endif
 };
 
 /*
@@ -7444,10 +7450,21 @@ struct wmi_chan_survey_req_cmd {
 	__le32 bb_xpa_timing;
 } __packed;
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+/*Smart antenna related defs */
+
 #define WMI_SMART_ANT_GPIO_MAX		4
 #define WMI_SMART_ANT_MODE_SERIAL	0
+#define WMI_SMART_ANT_MODE_PARALLEL	1
 #define WMI_SMART_ANT_DISABLE		0
 #define WMI_SMART_ANT_ENABLE		1
+#define WMI_SMART_ANT_RATE_SERIES_MAX	2
+#define WMI_SMART_ANT_NODE_CONFIG_ARGS_LEN  4
+#define WMI_SMART_ANT_TX_FEEDBACK_CONFIG_CMD	0x1
+
+#define WMI_CCK_OFDM_RATES_MAX		12
+#define WMI_MCS_RATES_MAX		32
+#define WMI_RATE_COUNT_MAX		4
 
 struct wmi_pdev_set_smart_ant_cmd {
 	/* 1 - enable, 0 - disable */
@@ -7469,6 +7486,61 @@ struct wmi_pdev_set_smart_ant_cmd {
 	__le32 gpio_func[WMI_SMART_ANT_GPIO_MAX];
 } __packed;
 
+struct wmi_pdev_set_rx_antenna_cmd {
+	__le32 rx_antenna;
+} __packed;
+
+struct wmi_peer_set_smart_tx_ant_cmd {
+	__le32 vdev_id;
+	struct wmi_mac_addr peer_macaddr;
+	__le32 ant_series[WMI_SMART_ANT_RATE_SERIES_MAX];
+} __packed;
+
+struct wmi_peer_cfg_smart_ant_cmd {
+	__le32 vdev_id;
+	struct wmi_mac_addr peer_macaddr;
+	__le32 cmd_id;
+	__le32 arg_cnt;
+	__le32 args[WMI_SMART_ANT_NODE_CONFIG_ARGS_LEN];
+} __packed;
+
+struct wmi_smart_ant_sta_cfg_arg {
+	u32 vdev_id;
+	struct wmi_mac_addr mac_addr;
+	u32 num_cfg;
+	u32 cfg[WMI_SMART_ANT_NODE_CONFIG_ARGS_LEN];
+};
+
+struct wmi_peer_set_smart_ant_train_info_cmd {
+	__le32 vdev_id;
+	struct wmi_mac_addr mac_addr;
+	__le32 train_rates[WMI_SMART_ANT_RATE_SERIES_MAX];
+	__le32 train_ants[WMI_SMART_ANT_RATE_SERIES_MAX];
+	__le32 num_pkts;
+	/* Rate control flags for future use */
+	__le32 rc_flas[WMI_SMART_ANT_RATE_SERIES_MAX];
+} __packed;
+
+struct wmi_peer_sant_set_train_arg {
+	u32 rates[WMI_SMART_ANT_RATE_SERIES_MAX];
+	u32 antennas[WMI_SMART_ANT_RATE_SERIES_MAX];
+	u32 num_pkts;
+};
+
+struct wmi_peer_rate_info {
+	u8 ratecode_legacy[WMI_CCK_OFDM_RATES_MAX];
+	u8 ratecode_20[WMI_MCS_RATES_MAX];
+	u8 ratecode_40[WMI_MCS_RATES_MAX];
+	u8 ratecode_80[WMI_MCS_RATES_MAX];
+	u8 ratecount[WMI_RATE_COUNT_MAX];
+} __packed;
+
+struct wmi_peer_ratecode_list_event {
+	struct wmi_mac_addr peer_macaddr;
+	struct wmi_peer_rate_info peer_rate_info;
+} __packed;
+#endif
+
 struct ath10k;
 struct ath10k_vif;
 struct ath10k_fw_stats_pdev;
-- 
2.43.0

