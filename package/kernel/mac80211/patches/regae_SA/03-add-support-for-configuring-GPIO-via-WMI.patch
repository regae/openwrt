From f2a827964ba970922273abcdb335b882c0e91e07 Mon Sep 17 00:00:00 2001
From: oliverwen <oliverwen@google.com>
Date: Fri, 24 Jun 2016 17:14:10 -0700
Subject: [PATCH] CHROMIUM: ath10k: add support for configuring GPIO via WMI

This patch add support to configure GPIO pins through wmi functions.

TEST=build/boot. Load ath10k_core with modparam set enable_smart_antenna=1,
bring up AP mode using hostapd and connect a station to this AP.
Device was able to connect to the internet and load multiple websites.
This testing is done on AP148.

BUG=chrome-os-partner:51964

Signed-off-by: oliverwen <oliverwen@google.com>
(cherry picked from commit 8160cb1a46f2750f33247c7ddc1e645e2613d54e)
(source: wireless-3.18)

Change-Id: I38e3d58d98ebe32389e7a1959a64179f30712387
Reviewed-on: https://chromium-review.googlesource.com/341523
Commit-Ready: Yixiang Li <yixiang@google.com>
Tested-by: Oliver Wen <oliverwen@chromium.org>
Reviewed-by: Yixiang Li <yixiang@google.com>
---
 drivers/net/wireless/ath/ath10k/Kconfig   |   7 ++
 drivers/net/wireless/ath/ath10k/hw.h      |  15 +++
 drivers/net/wireless/ath/ath10k/wmi-ops.h |  44 +++++++
 drivers/net/wireless/ath/ath10k/wmi.c     | 108 ++++++++++++++++++
 drivers/net/wireless/ath/ath10k/wmi.h     |  27 +++++
 5 files changed, 201 insertions(+)

diff --git a/drivers/net/wireless/ath/ath10k/Kconfig b/drivers/net/wireless/ath/ath10k/Kconfig
index db1ca629cbd..36c8c8224bb 100644
--- a/drivers/net/wireless/ath/ath10k/Kconfig
+++ b/drivers/net/wireless/ath/ath10k/Kconfig
@@ -115,3 +115,10 @@ config ATH10K_DFS_CERTIFIED
 	help
 	This option enables DFS support for initiating radiation on
 	ath10k.
+
+config ATH10K_SMART_ANTENNA
+	bool "QCA Smart Antenna support"
+	depends on ATH10K
+	default n
+	---help---
+	This option enables Smart Antenna API support.
diff --git a/drivers/net/wireless/ath/ath10k/hw.h b/drivers/net/wireless/ath/ath10k/hw.h
index 8a5d4fcb531..874a9f706b9 100644
--- a/drivers/net/wireless/ath/ath10k/hw.h
+++ b/drivers/net/wireless/ath/ath10k/hw.h
@@ -1010,6 +1010,21 @@ enum ath10k_hw_4addr_pad {
 
 #define DRAM_BASE_ADDRESS			0x00400000
 
+/* GPIO pins and functions used for smart antenna */
+#define WLAN_GPIOPIN_ANTCHAIN0		12
+#define WLAN_GPIOPIN_ANTCHAIN1		13
+#define WLAN_GPIOPIN_ANTCHAIN2		14
+
+#define WLAN_GPIOFUNC_ANTCHAIN0		5
+#define WLAN_GPIOFUNC_ANTCHAIN1		WLAN_GPIOFUNC_ANTCHAIN0
+#define WLAN_GPIOFUNC_ANTCHAIN2		WLAN_GPIOFUNC_ANTCHAIN0
+
+#define WLAN_GPIOPIN_ANT_SERIAL_STROBE	2
+#define WLAN_GPIOPIN_ANT_SERIAL_DATA	3
+
+#define WLAN_GPIOFUNC_ANT_SERIAL_STROBE	5
+#define WLAN_GPIOFUNC_ANT_SERIAL_DAT	WLAN_GPIOFUNC_ANT_SERIAL_STROBE
+
 #define PCIE_BAR_REG_ADDRESS			0x40030
 
 #define MISSING 0
diff --git a/drivers/net/wireless/ath/ath10k/wmi-ops.h b/drivers/net/wireless/ath/ath10k/wmi-ops.h
index b40f7cb1120..c8d72697543 100644
--- a/drivers/net/wireless/ath/ath10k/wmi-ops.h
+++ b/drivers/net/wireless/ath/ath10k/wmi-ops.h
@@ -230,6 +230,14 @@ struct wmi_ops {
 					   u32 input, u32 pull_type, u32 intr_mode);
 
 	struct sk_buff *(*gen_gpio_output)(struct ath10k *ar, u32 gpio_num, u32 set);
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	struct sk_buff *(*gen_pdev_enable_smart_ant)(struct ath10k *ar,
+						     u32 mode, u32 tx_ant,
+						     u32 rx_ant);
+	struct sk_buff *(*gen_pdev_disable_smart_ant)(struct ath10k *ar,
+						      u32 mode, u32 tx_ant,
+						      u32 rx_ant);
+#endif
 };
 
 int ath10k_wmi_cmd_send(struct ath10k *ar, struct sk_buff *skb, u32 cmd_id);
@@ -1707,4 +1715,41 @@ ath10k_wmi_set_coex_param(struct ath10k *ar, u32 wlan_traffic_priority)
 	return ath10k_wmi_cmd_send(ar, skb,
 				   ar->wmi.cmd->per_peer_per_tid_config_cmdid);
 }
+
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+static inline int
+ath10k_wmi_pdev_enable_smart_ant(struct ath10k *ar, u32 mode,
+				 u32 tx_ant, u32 rx_ant)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_pdev_enable_smart_ant)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_pdev_enable_smart_ant(ar, mode, tx_ant, rx_ant);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb,
+				   ar->wmi.cmd->pdev_set_smart_ant_cmdid);
+}
+
+static inline int
+ath10k_wmi_pdev_disable_smart_ant(struct ath10k *ar, u32 mode,
+				  u32 tx_ant, u32 rx_ant)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_pdev_disable_smart_ant)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_pdev_disable_smart_ant(ar, mode, tx_ant, rx_ant);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb,
+				   ar->wmi.cmd->pdev_set_smart_ant_cmdid);
+}
+#endif
+
 #endif
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index 6a95fe14fe7..33460342931 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -190,6 +190,9 @@ static struct wmi_cmd_map wmi_cmd_map = {
 	.pdev_bss_chan_info_request_cmdid = WMI_CMD_UNSUPPORTED,
 	.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,
 	.radar_found_cmdid = WMI_CMD_UNSUPPORTED,
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	.pdev_set_smart_ant_cmdid = WMI_CMD_UNSUPPORTED,
+#endif
 };
 
 /* 10.X WMI cmd track */
@@ -359,6 +362,9 @@ static struct wmi_cmd_map wmi_10x_cmd_map = {
 	.pdev_bss_chan_info_request_cmdid = WMI_CMD_UNSUPPORTED,
 	.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,
 	.radar_found_cmdid = WMI_CMD_UNSUPPORTED,
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	.pdev_set_smart_ant_cmdid = WMI_CMD_UNSUPPORTED,
+#endif
 };
 
 /* 10.2.4 WMI cmd track */
@@ -529,6 +535,9 @@ static struct wmi_cmd_map wmi_10_2_4_cmd_map = {
 	.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,
 	.radar_found_cmdid = WMI_CMD_UNSUPPORTED,
 	.set_bb_timing_cmdid = WMI_10_2_PDEV_SET_BB_TIMING_CONFIG_CMDID,
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	.pdev_set_smart_ant_cmdid = WMI_10_2_PDEV_SMART_ANT_ENABLE_CMDID,
+#endif
 };
 
 /* 10.4 WMI cmd track */
@@ -1509,6 +1518,9 @@ static struct wmi_cmd_map wmi_10_2_cmd_map = {
 	.pdev_reserve_ast_entry_cmdid = WMI_CMD_UNSUPPORTED,
 	.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,
 	.radar_found_cmdid = WMI_CMD_UNSUPPORTED,
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	.pdev_set_smart_ant_cmdid = WMI_10_2_PDEV_SMART_ANT_ENABLE_CMDID,
+#endif
 };
 
 static struct wmi_pdev_param_map wmi_10_4_pdev_param_map = {
@@ -9141,6 +9153,92 @@ ath10k_wmi_op_gen_chan_survey_send(struct ath10k *ar,
 	return skb;
 }
 
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+static void
+ath10k_wmi_fill_set_smart_ant(struct ath10k *ar,
+			      struct wmi_pdev_set_smart_ant_cmd *cmd,
+			      u32 mode, u32 tx_ant, u32 rx_ant)
+{
+	cmd->mode = __cpu_to_le32(mode);
+	cmd->rx_antenna = __cpu_to_le32(rx_ant);
+	cmd->tx_default_antenna = __cpu_to_le32(tx_ant);
+	if (mode == WMI_SMART_ANT_MODE_SERIAL) {
+		/* TODO: Get gpio pins from device tree */
+		cmd->gpio_pin[0] =
+			__cpu_to_le32(WLAN_GPIOPIN_ANT_SERIAL_STROBE);
+		cmd->gpio_pin[1] = __cpu_to_le32(WLAN_GPIOPIN_ANT_SERIAL_DATA);
+		cmd->gpio_pin[2] = 0;
+		cmd->gpio_pin[3] = 0;
+
+		cmd->gpio_func[0] =
+			__cpu_to_le32(WLAN_GPIOFUNC_ANT_SERIAL_STROBE);
+		cmd->gpio_func[1] =
+			__cpu_to_le32(WLAN_GPIOFUNC_ANT_SERIAL_STROBE);
+		cmd->gpio_func[2] = 0;
+		cmd->gpio_func[3] = 0;
+	} else {
+		/* TODO: Get gpio pins from device tree */
+		cmd->gpio_pin[0] = __cpu_to_le32(WLAN_GPIOPIN_ANTCHAIN0);
+		cmd->gpio_pin[1] = __cpu_to_le32(WLAN_GPIOPIN_ANTCHAIN1);
+		cmd->gpio_pin[2] = __cpu_to_le32(WLAN_GPIOPIN_ANTCHAIN2);
+		cmd->gpio_pin[3] = 0;
+
+		cmd->gpio_func[0] = __cpu_to_le32(WLAN_GPIOFUNC_ANTCHAIN0);
+		cmd->gpio_func[1] = __cpu_to_le32(WLAN_GPIOFUNC_ANTCHAIN1);
+		cmd->gpio_func[2] = __cpu_to_le32(WLAN_GPIOFUNC_ANTCHAIN2);
+		cmd->gpio_func[3] = 0;
+	}
+}
+
+/* Sends initial smart antenna configuration. The configuration includes
+ * enabling smart antenna functionality in fw, mode used for smart antenna
+ * {mode: parallel or serial GPIOs}, initial tx/rx antenna.
+ */
+static struct sk_buff *
+ath10k_wmi_op_gen_pdev_enable_smart_ant(struct ath10k *ar, u32 mode,
+					u32 tx_ant, u32 rx_ant)
+{
+	struct wmi_pdev_set_smart_ant_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_pdev_set_smart_ant_cmd *)skb->data;
+	cmd->enable = __cpu_to_le32(WMI_SMART_ANT_ENABLE);
+	ath10k_wmi_fill_set_smart_ant(ar, cmd, mode, tx_ant, rx_ant);
+	ath10k_dbg(ar, ATH10K_DBG_WMI,
+		   "wmi pdev smart antenna enable, mode %d rx_ant %d def_tx_ant %d\n",
+		   mode, rx_ant, tx_ant);
+	return skb;
+}
+
+/* Sends configurations to disable smart antenna, configuration includes bit
+ * indicating disable, GPIOs, mode for which it was enabled and tx/rx antennas
+ * to be reset, usually 0 is sent in tx/rx antenna in this command.
+ */
+static struct sk_buff *
+ath10k_wmi_op_gen_pdev_disable_smart_ant(struct ath10k *ar, u32 mode,
+					 u32 tx_ant, u32 rx_ant)
+{
+	struct wmi_pdev_set_smart_ant_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_pdev_set_smart_ant_cmd *)skb->data;
+	cmd->enable = __cpu_to_le32(WMI_SMART_ANT_DISABLE);
+	ath10k_wmi_fill_set_smart_ant(ar, cmd, mode, tx_ant, rx_ant);
+	ath10k_dbg(ar, ATH10K_DBG_WMI,
+		   "wmi pdev smart antenna disable, mode %d rx_ant %d def_tx_ant %d\n",
+		   mode, rx_ant, tx_ant);
+	return skb;
+}
+#endif
+
 static const struct wmi_ops wmi_ops = {
 	.rx = ath10k_wmi_op_rx,
 	.map_svc = wmi_main_svc_map,
@@ -9211,6 +9309,8 @@ static const struct wmi_ops wmi_ops = {
 	/* .gen_p2p_go_bcn_ie not implemented */
 	/* .gen_adaptive_qcs not implemented */
 	/* .gen_pdev_enable_adaptive_cca not implemented */
+	/* .gen_pdev_enable_smart_ant not implemented */
+	/* .gen_pdev_disable_smart_ant not implemented */
 };
 
 static const struct wmi_ops wmi_10_1_ops = {
@@ -9283,6 +9383,8 @@ static const struct wmi_ops wmi_10_1_ops = {
 	/* .gen_p2p_go_bcn_ie not implemented */
 	/* .gen_adaptive_qcs not implemented */
 	/* .gen_pdev_enable_adaptive_cca not implemented */
+	/* .gen_pdev_enable_smart_ant not implemented */
+	/* .gen_pdev_disable_smart_ant not implemented */
 };
 
 static const struct wmi_ops wmi_10_2_ops = {
@@ -9353,6 +9455,10 @@ static const struct wmi_ops wmi_10_2_ops = {
 	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
 	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 	/* .gen_pdev_enable_adaptive_cca not implemented */
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	.gen_pdev_enable_smart_ant  = ath10k_wmi_op_gen_pdev_enable_smart_ant,
+	.gen_pdev_disable_smart_ant  = ath10k_wmi_op_gen_pdev_disable_smart_ant,
+#endif
 };
 
 static const struct wmi_ops wmi_10_2_4_ops = {
@@ -9429,6 +9535,10 @@ static const struct wmi_ops wmi_10_2_4_ops = {
 	/* .gen_prb_tmpl not implemented */
 	/* .gen_p2p_go_bcn_ie not implemented */
 	/* .gen_adaptive_qcs not implemented */
+#ifdef CPTCFG_ATH10K_SMART_ANTENNA
+	.gen_pdev_enable_smart_ant  = ath10k_wmi_op_gen_pdev_enable_smart_ant,
+	.gen_pdev_disable_smart_ant  = ath10k_wmi_op_gen_pdev_disable_smart_ant,
+#endif
 };
 
 static const struct wmi_ops wmi_10_4_ops = {
diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h
index ee50edae6f2..329c659e1f1 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.h
+++ b/drivers/net/wireless/ath/ath10k/wmi.h
@@ -1045,6 +1045,7 @@ struct wmi_cmd_map {
 	u32 radar_found_cmdid;
 	u32 set_bb_timing_cmdid;
 	u32 per_peer_per_tid_config_cmdid;
+	u32 pdev_set_smart_ant_cmdid;
 };
 
 /*
@@ -7443,6 +7444,31 @@ struct wmi_chan_survey_req_cmd {
 	__le32 bb_xpa_timing;
 } __packed;
 
+#define WMI_SMART_ANT_GPIO_MAX		4
+#define WMI_SMART_ANT_MODE_SERIAL	0
+#define WMI_SMART_ANT_DISABLE		0
+#define WMI_SMART_ANT_ENABLE		1
+
+struct wmi_pdev_set_smart_ant_cmd {
+	/* 1 - enable, 0 - disable */
+	__le32 enable;
+
+	/* 1 - GPIO parallel mode, 0 - GPIO serial mode */
+	__le32 mode;
+
+	/* Rx antenna */
+	__le32 rx_antenna;
+
+	/* Default antenna used for Tx */
+	__le32 tx_default_antenna;
+
+	/* For serial 0 - strobe, 1 - data. Per stream GPIO in parallel */
+	__le32 gpio_pin[WMI_SMART_ANT_GPIO_MAX];
+
+	/* GPIO functions */
+	__le32 gpio_func[WMI_SMART_ANT_GPIO_MAX];
+} __packed;
+
 struct ath10k;
 struct ath10k_vif;
 struct ath10k_fw_stats_pdev;
-- 
2.43.0

