From 8a8e30bca57504e128c8026c1d959e1b6f7bfc8a Mon Sep 17 00:00:00 2001
From: Oliver Wen <oliverwen@google.com>
Date: Wed, 9 Sep 2015 16:33:04 -0700
Subject: [PATCH] CHROMIUM: smart antenna algorithm: verification

 - add debug level to smart antenna debug messages

TEST=echo 1 >/sys/kernel/debug/
.../ath10k/smart_antenna/smart_ant_debug_level,
debug message "Smart antenna debug level is set to be 1"
and those smart antenna debug messages with
smart_antenna_debug_level=1 should be logged in /var/log/messages

BUG=chrome-os-partner:51964
CQ-DEPEND=CL:341554

Signed-off-by: Oliver Wen <oliverwen@chromium.org>
(cherry picked from commit ab8b49fc0f205b21e10d1b7fcae078fcc0aa4a79)
(source: wireless-3.18)

Change-Id: I75080d24272be6485417f50ccb152d701600f54a
Reviewed-on: https://chromium-review.googlesource.com/341555
Commit-Ready: Yixiang Li <yixiang@google.com>
Tested-by: Oliver Wen <oliverwen@chromium.org>
Reviewed-by: Yixiang Li <yixiang@google.com>
---
 .../wireless-4.2/ath/ath10k/debug_smart_ant.c |  58 +++
 .../net/wireless-4.2/ath/ath10k/smart_ant.c   | 397 +++++++++++++-----
 .../net/wireless-4.2/ath/ath10k/smart_ant.h   |  11 +-
 3 files changed, 359 insertions(+), 107 deletions(-)

diff --git a/drivers/net/wireless/ath/ath10k/debug_smart_ant.c b/drivers/net/wireless/ath/ath10k/debug_smart_ant.c
index 5056d34a081..cced0264fba 100644
--- a/drivers/net/wireless/ath/ath10k/debug_smart_ant.c
+++ b/drivers/net/wireless/ath/ath10k/debug_smart_ant.c
@@ -494,6 +494,59 @@ static const struct file_operations fops_sa_train_info_ops = {
 	.llseek = default_llseek,
 };
 
+static ssize_t ath10k_write_sa_debug_level_ops(struct file *file,
+					       const char __user *user_buf,
+					       size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	u8 debug_level;
+
+	if (!ath10k_smart_ant_enabled(ar))
+		return -ENOTSUPP;
+
+	if (kstrtou8_from_user(user_buf, count, 0, &debug_level))
+		return -EINVAL;
+
+	if (ar->smart_ant_info.debug_level == debug_level)
+		return count;
+
+	mutex_lock(&ar->conf_mutex);
+
+	ar->smart_ant_info.debug_level = debug_level;
+
+	ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "Smart antenna debug level is set to be %d\n",
+		   debug_level);
+
+	mutex_unlock(&ar->conf_mutex);
+
+	return count;
+}
+
+static ssize_t ath10k_read_sa_debug_level_ops(
+				struct file *file, char __user *ubuf,
+				size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	char buf[4];
+	int len = 0;
+
+	if (!ath10k_smart_ant_enabled(ar))
+		return -ENOTSUPP;
+
+	len = scnprintf(buf, sizeof(buf) - len, "%d\n",
+			ar->smart_ant_info.debug_level);
+
+	return simple_read_from_buffer(ubuf, count, ppos, buf, len);
+}
+
+static const struct file_operations fops_sa_debug_level_ops = {
+	.write = ath10k_write_sa_debug_level_ops,
+	.read = ath10k_read_sa_debug_level_ops,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
 void ath10k_smart_ant_debugfs_init(struct ath10k *ar)
 {
 	ar->debug.debugfs_smartant = debugfs_create_dir("smart_antenna",
@@ -535,5 +588,10 @@ void ath10k_smart_ant_debugfs_init(struct ath10k *ar)
 	debugfs_create_file(
 		"smart_ant_train_info", S_IWUSR,
 		ar->debug.debugfs_smartant, ar, &fops_sa_train_info_ops);
+
+	debugfs_create_file(
+		"smart_ant_debug_level", S_IRUSR | S_IWUSR,
+		ar->debug.debugfs_smartant, ar,
+		&fops_sa_debug_level_ops);
 }
 #endif
diff --git a/drivers/net/wireless/ath/ath10k/smart_ant.c b/drivers/net/wireless/ath/ath10k/smart_ant.c
index 6d1db38d319..7ea77d9e46a 100644
--- a/drivers/net/wireless/ath/ath10k/smart_ant.c
+++ b/drivers/net/wireless/ath/ath10k/smart_ant.c
@@ -73,11 +73,16 @@ smart_ant_dbg_ratelist(struct ath10k *ar,
 	}
 
 	rcount = rtcode->rt_count[mode];
-	ath10k_dbg(
-		ar, ATH10K_DBG_SMART_ANT,
-		"rate code list for mode %s\n", rate_code_map[mode]);
-	for (i = 0; i < rcount; i++)
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "0x%x\n", rlist[i]);
+
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+		ath10k_dbg(
+		    ar, ATH10K_DBG_SMART_ANT,
+		    "rate code list for mode %s\n", rate_code_map[mode]);
+		for (i = 0; i < rcount; i++)
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "0x%x\n", rlist[i]);
+	}
 }
 
 static void smart_ant_dbg_feedback(struct ath10k *ar,
@@ -87,32 +92,46 @@ static void smart_ant_dbg_feedback(struct ath10k *ar,
 
 	if (fb->num_comb_fb) {
 		for (i = 0; i < fb->num_comb_fb; i++) {
-			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-				   "Combined feedback[%d] npkts %d nbad %d bw %d rate 0x%x num_comb_fb %d Train pkt: %s rate_maxphy 0x%x rate_idx %d goodput %d tx_antenna[0]: %d tx_antenna[1]: %d rate_mcs[0] 0x%x rate_mcs[1] 0x%x\n",
-				   i, fb->comb_fb[i].npkts, fb->comb_fb[i].nbad,
-				   ATH10K_COMB_FB_BW(fb->comb_fb[i].bw),
-				   fb->comb_fb[i].rate, fb->num_comb_fb,
-				   fb->train_pkt ? "True" : "False",
-				   fb->rate_maxphy, fb->ridx, fb->gput,
-				   fb->tx_antenna[0], fb->tx_antenna[0],
-				   fb->rate_mcs[0], fb->rate_mcs[1]);
+			if (ar->smart_ant_info.debug_level >=
+			    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+				ath10k_dbg(
+				    ar, ATH10K_DBG_SMART_ANT,
+				    "Combined feedback[%d] npkts %d nbad %d bw %d rate 0x%x num_comb_fb %d Train pkt: %s rate_maxphy 0x%x rate_idx %d goodput %d tx_antenna[0]: %d tx_antenna[1]: %d rate_mcs[0] 0x%x rate_mcs[1] 0x%x\n",
+				    i,
+				    fb->comb_fb[i].npkts,
+				    fb->comb_fb[i].nbad,
+				    ATH10K_COMB_FB_BW(fb->comb_fb[i].bw),
+				    fb->comb_fb[i].rate, fb->num_comb_fb,
+				    fb->train_pkt ? "True" : "False",
+				    fb->rate_maxphy, fb->ridx, fb->gput,
+				    fb->tx_antenna[0], fb->tx_antenna[0],
+				    fb->rate_mcs[0], fb->rate_mcs[1]);
+			}
 		}
 	} else {
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-			   "Regular feedback npkts %d nbad %d bw %d rate 0x%x num_comb_fb %d Train pkt: %s rate_maxphy 0x%x rate_idx %d goodput %d tx_antenna[0]: %d tx_antenna[1]: %d rate_mcs[0] 0x%x rate_mcs[1] 0x%x\n",
-			   fb->npkts, fb->nbad, ATH10K_FB_BW(fb->ridx),
-			   ATH10K_FB_RATE(fb->rate_mcs[0],
-					  ATH10K_FB_BW(fb->ridx)),
-			   fb->num_comb_fb, fb->train_pkt ? "True" : "False",
-			   fb->rate_maxphy,
-			   fb->ridx, fb->gput,
-			   fb->tx_antenna[0], fb->tx_antenna[0],
-			   fb->rate_mcs[0], fb->rate_mcs[1]);
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+			ath10k_dbg(
+			    ar, ATH10K_DBG_SMART_ANT,
+			    "Regular feedback npkts %d nbad %d bw %d rate 0x%x num_comb_fb %d Train pkt: %s rate_maxphy 0x%x rate_idx %d goodput %d tx_antenna[0]: %d tx_antenna[1]: %d rate_mcs[0] 0x%x rate_mcs[1] 0x%x\n",
+			    fb->npkts, fb->nbad,
+			    ATH10K_FB_BW(fb->ridx),
+			    ATH10K_FB_RATE(
+				fb->rate_mcs[0], ATH10K_FB_BW(fb->ridx)),
+			    fb->num_comb_fb, fb->train_pkt ? "True" : "False",
+			    fb->rate_maxphy,
+			    fb->ridx, fb->gput,
+			    fb->tx_antenna[0], fb->tx_antenna[0],
+			    fb->rate_mcs[0], fb->rate_mcs[1]);
+		}
 	}
 
-	for (i = 0; i < ATH10K_SMART_ANT_MAX_CHAINS; i++) {
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "rssi[%d] %d\n",
-			   i, (u8)fb->rssi[i]);
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+		for (i = 0; i < ATH10K_SMART_ANT_MAX_CHAINS; i++) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "rssi[%d] %d\n",
+				   i, (u8)fb->rssi[i]);
+		}
 	}
 }
 
@@ -328,10 +347,15 @@ static void smart_ant_set_train_params(struct ath10k *ar,
 	min_t(u16, num_pkts, ATH10K_SMART_ANT_TRAIN_PKT_MAX);
 
 	tdata->num_pkts = num_pkts;
-	ath10k_dbg(
-	    ar, ATH10K_DBG_SMART_ANT,
-	    "set_train_params tx_antenna %d rate %x nFrames %d num_pkts %d\n",
-	    tdata->antenna, tdata->rate_code, tdata->nframes, tdata->num_pkts);
+
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATES) {
+		ath10k_dbg(
+		    ar, ATH10K_DBG_SMART_ANT,
+		    "set_train_params tx_antenna %d rate %x nFrames %d num_pkts %d\n",
+		    tdata->antenna, tdata->rate_code,
+		    tdata->nframes, tdata->num_pkts);
+	}
 }
 
 static u8 ath10k_smart_ant_get_train_rate(struct ath10k_smart_ant_sta *sa_sta)
@@ -559,10 +583,26 @@ static u8 smart_ant_sel_rx_ant(struct ath10k *ar,
 	sa_info->num_sta_per_ant[tinfo->prev_sel_ant]--;
 	sa_info->num_sta_per_ant[tinfo->sel_ant]++;
 	nsta_sel_ant = sa_info->num_sta_per_ant[tinfo->sel_ant];
+
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATES) {
+		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+			   "sa_info->default_ant = %d, tinfo->sel_ant= %d\n sa_info->num_sta_conneted = %d, nsta_sel_ant = %d\n",
+			   sa_info->default_ant, tinfo->sel_ant,
+			   sa_info->num_sta_conneted, nsta_sel_ant);
+	}
+
 	if ((tinfo->sel_ant != sa_info->default_ant) &&
 	    (sa_info->num_sta_conneted == nsta_sel_ant)) {
 		sa_info->default_ant = tinfo->sel_ant;
 		status = ATH10K_SMART_ANT_ACT_RX_CFG;
+
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATES) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "Rx antenna is going to be config to %d\n",
+				   tinfo->sel_ant);
+		}
 	}
 
 	tinfo->prev_sel_ant = tinfo->sel_ant;
@@ -684,12 +724,16 @@ static u8 smart_ant_proc_train_stats(struct ath10k *ar,
 	if (tdata->nframes)
 		per = (ATH10K_SMART_ANT_PER_MAX * tdata->nbad) / tdata->nframes;
 
-	ath10k_dbg(
-	    ar, ATH10K_DBG_SMART_ANT,
-	   "Stats for antenna %d: rate %x, nFrames: %d nBad %d, nppdu %d, RSSI %d %d %d PER: %d ",
-	   tdata->antenna, tdata->rate_code, tdata->nframes,
-	   tdata->nbad, tinfo->num_ppdu_bw[tstats->bw], tdata->rssi[0][0],
-	   tdata->rssi[1][0], tdata->rssi[2][0], per);
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+			   "Stats for antenna %d: rate %x, nFrames: %d nBad %d, nppdu %d, RSSI %d %d %d PER: %d ",
+			   tdata->antenna, tdata->rate_code, tdata->nframes,
+			   tdata->nbad, tinfo->num_ppdu_bw[tstats->bw],
+			   tdata->rssi[0][0],
+			   tdata->rssi[1][0],
+			   tdata->rssi[2][0], per);
+	}
 
 	/* TODO: Process extra stats */
 	if (tinfo->sel_ant == tstats->ant_map[tstats->antenna]) {
@@ -730,10 +774,23 @@ static u8 smart_ant_proc_train_stats(struct ath10k *ar,
 			per_diff = per < tstats->per ? tstats->per - per : 0;
 			if ((tstats->rate > tstats->last_rate) ||
 			    ((tstats->rate == tstats->last_rate) &&
-			     per_diff > sparams->per_diff_threshold &&
-			     tstats->per > sparams->low_rate_threshold))
+			    per_diff > sparams->per_diff_threshold &&
+			    tstats->per > sparams->low_rate_threshold)){
 				switch_ant = true;
 
+				if (ar->smart_ant_info.debug_level >=
+				    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+					ath10k_dbg(
+					    ar, ATH10K_DBG_SMART_ANT,
+					    "switch ant on higher rate: curr rate %d last rate %d per_diff %d per_diff_threshold %d stat PER %d low_rate_threshold %d\n",
+					    tstats->rate, tstats->last_rate,
+					    per_diff,
+					    sparams->per_diff_threshold,
+					    tstats->per,
+					    sparams->low_rate_threshold);
+				}
+			}
+
 			if (!switch_ant && tstats->rate == tstats->last_rate) {
 				tstats->next_ant_per = per;
 				tstats->next_ant_nbad = tdata->nbad;
@@ -745,6 +802,15 @@ static u8 smart_ant_proc_train_stats(struct ath10k *ar,
 			if (tstats->rate > tstats->last_rate &&
 			    per < sparams->hi_rate_threshold) {
 				switch_ant = true;
+
+				if (ar->smart_ant_info.debug_level >=
+				    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+					ath10k_dbg(
+					    ar, ATH10K_DBG_SMART_ANT,
+					    "switch ant on higher rate: curr rate %d last rate %d curr PER %d hi_rate_threshold %d\n",
+					    tstats->rate, tstats->last_rate,
+					    per, sparams->hi_rate_threshold);
+				}
 			} else if (tstats->rate > tstats->last_rate) {
 				per = tstats->next_ant_per;
 				tdata->nbad = tstats->next_ant_nbad;
@@ -760,9 +826,31 @@ static u8 smart_ant_proc_train_stats(struct ath10k *ar,
 			if (tstats->rate == tstats->last_rate &&
 			    per_diff <= sparams->per_diff_threshold)
 				switch_ant = smart_ant_sec_metric(sa_sta);
+
+				if (ar->smart_ant_info.debug_level >=
+				    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS &&
+				    switch_ant) {
+					ath10k_dbg(
+					    ar, ATH10K_DBG_SMART_ANT,
+					    "switch ant on higher RSSI: curr rate %d last rate %d per_diff %d per_diff_threshold %d\n",
+					    tstats->rate,
+					    tstats->last_rate,
+					    per_diff,
+					    sparams->per_diff_threshold);
+				}
 			else if (tstats->rate == tstats->last_rate &&
 				 per < tstats->per)
 				switch_ant = true;
+
+				if (ar->smart_ant_info.debug_level >=
+				    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+					ath10k_dbg(
+					    ar, ATH10K_DBG_SMART_ANT,
+					    "switch ant on lower per: curr rate %d last rate %d curr PER %d last PER %d\n",
+					    tstats->rate,
+					    tstats->last_rate,
+					    per, tstats->per);
+				}
 		}
 
 		if (switch_ant) {
@@ -775,12 +863,18 @@ static u8 smart_ant_proc_train_stats(struct ath10k *ar,
 			memcpy(tstats->rssi, tdata->rssi, sizeof(tdata->rssi));
 			if (per < sparams->low_rate_threshold)
 				nxt_rate_dir = 1;
-			ath10k_dbg(
-			    ar, ATH10K_DBG_SMART_ANT,
-			   "switching to:antenna %d PER %d RSSI %d %d %d rate %x\n",
-			   tstats->ant_map[tstats->antenna], tstats->per,
-			   tstats->rssi[0][0], tstats->rssi[1][0],
-			   tstats->rssi[2][0], tdata->rate_code);
+
+			if (ar->smart_ant_info.debug_level >=
+			    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+				ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+					   "switching to:antenna %d antMapIdx %d PER %d RSSI %d %d %d rate %x\n",
+					   tstats->ant_map[tstats->antenna],
+					   tstats->antenna, tstats->per,
+					   tstats->rssi[0][0],
+					   tstats->rssi[1][0],
+					   tstats->rssi[2][0],
+					   tdata->rate_code);
+			}
 		}
 	}
 
@@ -825,9 +919,16 @@ static u8 smart_ant_proc_train_stats(struct ath10k *ar,
 		tinfo->train_end_ts = jiffies;
 		tinfo->train_start = false;
 		tinfo->perf_mon_slot = tinfo->train_end_ts;
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-			   "Training completed:antenna selected %d\n",
-			   tstats->ant_map[0]);
+
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "Training completed:antenna selected %d\n",
+				   tstats->ant_map[0]);
+		}
+		/* force config tx/rx antenna after SA decision is made */
+		status |= ATH10K_SMART_ANT_ACT_TX_CFG;
+		status |= ATH10K_SMART_ANT_ACT_RX_CFG;
 	}
 
 	return status;
@@ -865,10 +966,15 @@ static u8 smart_ant_perf_train_trigger(struct ath10k *ar,
 			pinfo->avg_gput = pinfo->avg_gput ?
 				(pinfo->avg_gput + rstats->ins_gput[bw]) >> 1
 				: rstats->ins_gput[bw];
-			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-				   "BW: %d avg gput %d ins gput %d hyster %d",
-				   bw, pinfo->avg_gput, rstats->ins_gput[bw],
-				   pinfo->hysteresis);
+
+			if (ar->smart_ant_info.debug_level >=
+			    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+				ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+					   "BW: %d avg gput %d ins gput %d hyster %d",
+					   bw, pinfo->avg_gput,
+					   rstats->ins_gput[bw],
+					   pinfo->hysteresis);
+			}
 		}
 	} else {
 		thrshld = (pinfo->avg_gput * sparams.max_perf_delta) / 100;
@@ -876,10 +982,14 @@ static u8 smart_ant_perf_train_trigger(struct ath10k *ar,
 			thrshld = sparams.min_goodput_threshold;
 		pdelta = abs(pinfo->avg_gput - rstats->ins_gput[bw]);
 
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-			   "BW %d avg gput %d ins gput %d hyster %d thrshld %d pdelta: %d",
-			   bw, pinfo->avg_gput, rstats->ins_gput[bw],
-			   pinfo->hysteresis, thrshld, pdelta);
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "BW %d avg gput %d ins gput %d hyster %d thrshld %d pdelta: %d",
+				   bw, pinfo->avg_gput, rstats->ins_gput[bw],
+				   pinfo->hysteresis, thrshld, pdelta);
+		}
+
 		if (pdelta < thrshld) {
 			pinfo->hysteresis = 0;
 			pinfo->trig_type = ATH10K_SMART_ANT_TRIGGER_TYPE_INIT;
@@ -928,7 +1038,10 @@ static u8 smart_ant_perf_train_trigger(struct ath10k *ar,
 			sa_sta->train_info.train_state =
 					ATH10K_SMART_ANT_STATE_PRETRAIN;
 			status = ATH10K_SMART_ANT_ACT_TRAIN;
-			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "start Perf train\n");
+			if (ar->smart_ant_info.debug_level >=
+				ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+				ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "start Perf train\n");
+			}
 		}
 	}
 
@@ -948,9 +1061,15 @@ static u8 smart_ant_retrain_trigger(struct ath10k *ar,
 	elapsed_ts = current_ts - sa_sta->train_info.train_end_ts;
 	if (elapsed_ts > sparams.retrain_interval ||
 	    sa_sta->train_info.train_start) {
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "start Periodic train\n");
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "start Periodic train\n");
+		}
+
 		sa_sta->train_info.train_state =
 			ATH10K_SMART_ANT_STATE_PRETRAIN;
+
 		return ATH10K_SMART_ANT_ACT_TRAIN;
 	}
 
@@ -1013,10 +1132,13 @@ static void smart_ant_update_training(struct ath10k *ar,
 
 		rate_cfg = ATH10K_FB_RATE(tdata->rate_code, bw);
 		if (fb->tx_antenna[0] != tdata->antenna || rate_cfg != rate) {
-			ath10k_dbg(
-			    ar, ATH10K_DBG_SMART_ANT,
-			   "train pkt with mismatch: tdata antenna: %d fb_antenna %d cfg_rates: %x fb_rate: %x\n",
-			   tdata->antenna, fb->tx_antenna[0], rate_cfg, rate);
+			if (ar->smart_ant_info.debug_level >=
+			    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS) {
+				ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+					   "train pkt with mismatch: tdata antenna: %d fb_antenna %d cfg_rates: %x fb_rate: %x\n",
+					   tdata->antenna, fb->tx_antenna[0],
+					   rate_cfg, rate);
+			}
 			continue;
 		}
 
@@ -1046,8 +1168,12 @@ static void smart_ant_update_training(struct ath10k *ar,
 	    tinfo->train_stats.bw != ATH10K_SMART_ANT_BW_20) {
 		smart_ant_change_bw(ar, sa_sta);
 		if (tinfo->train_stats.bw_change) {
-			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-				   "Trigger training due to bandwidth change\n");
+			if (ar->smart_ant_info.debug_level >=
+			    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+				ath10k_dbg(
+				 ar, ATH10K_DBG_SMART_ANT,
+				 "Trigger training due to bandwidth change\n");
+			}
 			*action |= ATH10K_SMART_ANT_ACT_TRAIN;
 		}
 	}
@@ -1111,10 +1237,12 @@ static void smart_ant_cfg_work(struct work_struct *work)
 			break;
 		default:
 		case ATH10K_SMART_ANT_TYPE_MAX:
-			ath10k_dbg(
-			   ar, ATH10K_DBG_SMART_ANT,
-			   "Not a supported config type :%d\n",
-			   cfg->type);
+			if (ar->smart_ant_info.debug_level >=
+			    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+				ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+					   "Not a supported config type :%d\n",
+					   cfg->type);
+			}
 		}
 
 		mutex_unlock(&ar->conf_mutex);
@@ -1141,8 +1269,13 @@ static int smart_ant_config_tx(struct ath10k *ar,
 	ether_addr_copy(cfg->tx_ant_cfg.peer_mac, peer_mac);
 	smart_ant_get_tx_ant(sa_sta, cfg->tx_ant_cfg.tx_ants);
 
-	ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "Configure tx antenna for %pM to %d\n",
-		   cfg->tx_ant_cfg.peer_mac, cfg->tx_ant_cfg.tx_ants[0]);
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+			   "Configure tx antenna for %pM to %d\n",
+			   cfg->tx_ant_cfg.peer_mac,
+			   cfg->tx_ant_cfg.tx_ants[0]);
+	}
 
 	spin_lock_bh(&sa_sta->cfg_lock);
 	list_add_tail(&cfg->list, &sa_sta->cfg_list);
@@ -1166,8 +1299,13 @@ static int smart_ant_config_rx(struct ath10k *ar,
 	cfg->type = ATH10K_SMART_ANT_TYPE_RX_CFG;
 	cfg->rx_ant_cfg.rx_ant = info->default_ant;
 
-	ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "Configure Rx antenna to %d\n",
-		   cfg->rx_ant_cfg.rx_ant);
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+			   "Configure Rx antenna to %d\n",
+			   cfg->rx_ant_cfg.rx_ant);
+	}
+
 	spin_lock_bh(&sa_sta->cfg_lock);
 	list_add_tail(&cfg->list, &sa_sta->cfg_list);
 	spin_unlock_bh(&sa_sta->cfg_lock);
@@ -1193,13 +1331,17 @@ static int smart_ant_config_train_info(struct ath10k *ar,
 	smart_ant_get_train_info(ar, sa_sta,
 				 &cfg->train_info_cfg.train_info);
 
-	ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-		   "Configure train information peer: %pM vdev_id: %d num_pkts:%d tx_antenna[0] %d tx_antenna[1] %d rates [0] %x",
-		   cfg->train_info_cfg.peer_mac, cfg->train_info_cfg.vdev_id,
-		   cfg->train_info_cfg.train_info.num_pkts,
-		   cfg->train_info_cfg.train_info.antennas[0],
-		   cfg->train_info_cfg.train_info.antennas[1],
-		   cfg->train_info_cfg.train_info.rates[0]);
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATES) {
+		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+			   "Configure train information peer: %pM vdev_id: %d num_pkts:%d tx_antenna[0] %d tx_antenna[1] %d rates [0] %x",
+			   cfg->train_info_cfg.peer_mac,
+			   cfg->train_info_cfg.vdev_id,
+			   cfg->train_info_cfg.train_info.num_pkts,
+			   cfg->train_info_cfg.train_info.antennas[0],
+			   cfg->train_info_cfg.train_info.antennas[1],
+			   cfg->train_info_cfg.train_info.rates[0]);
+	}
 
 	spin_lock_bh(&sa_sta->cfg_lock);
 	list_add_tail(&cfg->list, &sa_sta->cfg_list);
@@ -1234,8 +1376,12 @@ static void smart_ant_tx_stats_update(struct ath10k *ar,
 		}
 
 		if (tinfo->num_tx_pkts >= sparams->num_pretrain_pkts) {
-			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-				   "Exceeded number of pretrain pkts, trigger training\n");
+			if (ar->smart_ant_info.debug_level >=
+			    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+				ath10k_dbg(
+				    ar, ATH10K_DBG_SMART_ANT,
+				    "Exceeded number of pretrain pkts, trigger training\n");
+			}
 			*action |= ATH10K_SMART_ANT_ACT_TRAIN;
 		}
 		break;
@@ -1251,9 +1397,12 @@ static void smart_ant_tx_stats_update(struct ath10k *ar,
 	}
 
 	if (*action != 0) {
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-			   "Action after Tx status update:0x%x train_state:%d\n",
-			   *action, sa_sta->train_info.train_state);
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATES) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "Action after Tx status update:0x%x train_state:%d\n",
+				   *action, sa_sta->train_info.train_state);
+		}
 	}
 }
 
@@ -1443,8 +1592,12 @@ void ath10k_smart_ant_proc_tx_feedback(struct ath10k *ar, u8 *data)
 		sta = ieee80211_find_sta_by_ifaddr(ar->hw, peer_mac, NULL);
 		if (!sta) {
 			rcu_read_unlock();
-			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-				   "Sta entry for %pM not found\n", peer_mac);
+			if (ar->smart_ant_info.debug_level >=
+			    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES) {
+				ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+					   "Sta entry for %pM not found\n",
+					   peer_mac);
+			}
 			return;
 		}
 
@@ -1454,8 +1607,14 @@ void ath10k_smart_ant_proc_tx_feedback(struct ath10k *ar, u8 *data)
 			goto exit;
 
 		memset(&feed_back, 0, sizeof(feed_back));
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT, "Tx feedback from sta: %pM\n",
-			   peer_mac);
+
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATES) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "Tx feedback from sta: %pM\n",
+				   peer_mac);
+		}
+
 		smart_ant_tx_fb_fill(ar, tx_ctrl_desc, &feed_back);
 
 		smart_ant_tx_stats_update(ar, arsta->smart_ant_sta,
@@ -1520,8 +1679,12 @@ void ath10k_smart_ant_sta_disconnect(struct ath10k *ar,
 	if (!ath10k_smart_ant_enabled(ar) || !arsta->smart_ant_sta)
 		return;
 
-	ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-		"Smart antenna disconnect for %pM\n", sta->addr);
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION) {
+		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+			   "Smart antenna disconnect for %pM\n",
+			   sta->addr);
+	}
 
 	sa_sta = arsta->smart_ant_sta;
 	cancel_work_sync(&sa_sta->sa_wmi_cfg_work);
@@ -1559,8 +1722,11 @@ int ath10k_smart_ant_sta_connect(struct ath10k *ar,
 
 	if (arvif->vdev_type != WMI_VDEV_TYPE_AP ||
 	    arvif->vdev_subtype != WMI_VDEV_SUBTYPE_NONE) {
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-			   "Smart antenna logic not enabled for non-AP interface\n");
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "Smart antenna logic not enabled for non-AP interface\n");
+		}
 		return 0;
 	}
 
@@ -1573,8 +1739,12 @@ int ath10k_smart_ant_sta_connect(struct ath10k *ar,
 	memcpy(&smart_ant_sta->rate_cap, &ar->ratecode_list,
 	       sizeof(smart_ant_sta->rate_cap));
 
-	ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-		   "Smart antenna connect for %pM\n", sta->addr);
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION) {
+		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+			   "Smart antenna connect for %pM\n",
+			   sta->addr);
+	}
 
 	for (i = 0; i < ATH10K_SMART_ANT_RTCNT_MAX; i++)
 		smart_ant_dbg_ratelist(ar, &ar->ratecode_list, i);
@@ -1588,13 +1758,19 @@ int ath10k_smart_ant_sta_connect(struct ath10k *ar,
 	arg.vdev_id = arsta->arvif->vdev_id;
 	ether_addr_copy(arg.mac_addr.addr, sta->addr);
 
-	ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-		   "%s mac %pM vdev_id %d num_cfg %d\n",
-		__func__, arg.mac_addr.addr, arg.vdev_id, arg.num_cfg);
-
-	for (i = 0; i < arg.num_cfg; i++) {
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION) {
 		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-			   "cfg[%d] 0x%x\n", i, arg.cfg[i]);
+			   "%s mac %pM vdev_id %d num_cfg %d\n",
+			   __func__,
+			   arg.mac_addr.addr,
+			   arg.vdev_id,
+			   arg.num_cfg);
+
+		for (i = 0; i < arg.num_cfg; i++) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "cfg[%d] 0x%x\n", i, arg.cfg[i]);
+		}
 	}
 
 	/* Configure feedback option for this station, i.e tx feedback
@@ -1674,8 +1850,11 @@ int ath10k_smart_ant_set_default(struct ath10k *ar,
 
 	if (arvif->vdev_type != WMI_VDEV_TYPE_AP ||
 	    arvif->vdev_subtype != WMI_VDEV_SUBTYPE_NONE) {
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-			   "Smart antenna logic not enabled for non-AP interface\n");
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "Smart antenna logic not enabled for non-AP interface\n");
+		}
 		return 0;
 	}
 
@@ -1747,8 +1926,11 @@ int ath10k_smart_ant_enable(struct ath10k *ar, struct ath10k_vif *arvif)
 	 */
 	if (arvif->vdev_type != WMI_VDEV_TYPE_AP ||
 	    arvif->vdev_subtype != WMI_VDEV_SUBTYPE_NONE) {
-		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-			   "Smart antenna logic not enabled for non-AP interface\n");
+		if (ar->smart_ant_info.debug_level >=
+		    ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION) {
+			ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+				   "Smart antenna logic not enabled for non-AP interface\n");
+		}
 		return 0;
 	}
 
@@ -1758,8 +1940,11 @@ int ath10k_smart_ant_enable(struct ath10k *ar, struct ath10k_vif *arvif)
 
 	smart_ant_init_param(ar);
 
-	ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
-		   "Hw supports Smart antenna, enabling it in driver\n");
+	if (ar->smart_ant_info.debug_level >=
+	    ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION) {
+		ath10k_dbg(ar, ATH10K_DBG_SMART_ANT,
+			   "Hw supports Smart antenna, enabling it in driver\n");
+	}
 
 	/* Enable smart antenna logic in fw with mode and default antenna */
 	ret = ath10k_wmi_pdev_enable_smart_ant(ar, info->mode,
diff --git a/drivers/net/wireless/ath/ath10k/smart_ant.h b/drivers/net/wireless/ath/ath10k/smart_ant.h
index dcc5dc01dc4..aa89d22c89f 100644
--- a/drivers/net/wireless/ath/ath10k/smart_ant.h
+++ b/drivers/net/wireless/ath/ath10k/smart_ant.h
@@ -58,7 +58,7 @@
 #define ATH10K_SMART_ANT_RSSI_SAMPLE	10
 #define ATH10K_SMART_ANT_PER_MAX	100
 
-#define ATH10K_SMART_ANT_DEFAULT_ANT	2
+#define ATH10K_SMART_ANT_DEFAULT_ANT	5
 #define ATH10K_PPDU_SIZE_MAX		32
 
 /* Max number of antenna combinations 2 ^ max_supported_ant */
@@ -295,6 +295,14 @@ enum ath10k_smart_ant_feedback {
 	ATH10K_SMART_ANT_RX_FEEDBACK = 1 << 1,
 };
 
+enum ath10k_smart_ant_debug_level {
+	ATH10K_SMART_ANT_DBG_LVL_TOP_DECISION,
+	ATH10K_SMART_ANT_DBG_LVL_TRAIN_STAGES,
+	ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATES,
+	ATH10K_SMART_ANT_DBG_LVL_TRAIN_STATS,
+	ATH10K_SMART_ANT_DBG_LVL_ALL,
+};
+
 struct ath10k_smart_ant_wmi_cfg_param {
 	struct list_head list;
 	enum ath10k_smart_ant_cfg_msg_type type;
@@ -471,6 +479,7 @@ struct ath10k_smart_ant_info {
 	bool enabled;
 	u32 tx_ppdu_end[ATH10K_PPDU_SIZE_MAX];
 	u32 num_enabled_vif;
+	u8 debug_level;
 };
 
 #ifdef CPTCFG_ATH10K_SMART_ANT_ALG
-- 
2.43.0

